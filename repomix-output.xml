This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: ./**/*.md
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.claude/
  settings.local.json
.ruler/
  ruler.toml
public/
  easynext.png
src/
  app/
    (protected)/
      analysis/
        [id]/
          page.tsx
        new/
          page.tsx
      dashboard/
        page.tsx
      layout.tsx
    api/
      [[...hono]]/
        route.ts
    example/
      page.tsx
    sign-in/
      [[...sign-in]]/
        page.tsx
    sign-up/
      [[...sign-up]]/
        page.tsx
    subscription/
      page.tsx
    favicon.ico
    globals.css
    layout.tsx
    page.tsx
    providers.tsx
  backend/
    config/
      index.ts
    errors/
      codes.ts
    hono/
      app.ts
      context.ts
    http/
      response.ts
    integrations/
      gemini/
        client.ts
      tosspayments/
        client.ts
    middleware/
      auth.ts
      context.ts
      error.ts
      supabase.ts
    services/
      usage.ts
    supabase/
      client.ts
      helpers.ts
  components/
    common/
      loading-overlay.tsx
    ui/
      accordion.tsx
      alert.tsx
      avatar.tsx
      badge.tsx
      button.tsx
      card.tsx
      checkbox.tsx
      dialog.tsx
      dropdown-menu.tsx
      file-upload.tsx
      form.tsx
      input.tsx
      label.tsx
      progress.tsx
      radio-group.tsx
      select.tsx
      separator.tsx
      sheet.tsx
      skeleton.tsx
      textarea.tsx
      toast.tsx
      toaster.tsx
  constants/
    app.ts
    auth.ts
    env.ts
    landing.ts
  features/
    analysis/
      backend/
        error.ts
        route_dashboard.ts
        route.ts
        schema.ts
        service.ts
        service.ts.backup
      components/
        action-buttons.tsx
        analysis-form.tsx
        analysis-header.tsx
        analysis-new-page.tsx
        error-alert.tsx
        error-page.tsx
        result-section.tsx
        usage-display.tsx
      context/
        analysis-new-context.tsx
      hooks/
        use-analysis-detail.ts
      lib/
        dto.ts
        error.ts
    auth/
      backend/
        route.ts
        schema.ts
        service.ts
      context/
        current-user-context.tsx
      hooks/
        useCurrentUser.ts
      lib/
        dto.ts
      server/
        load-current-user.ts
      types.ts
    dashboard/
      backend/
        route.ts
        schema.ts
      components/
        analysis-card.tsx
        dashboard-header.tsx
        subscription-badge.tsx
        usage-indicator.tsx
      context/
        dashboard-context.tsx
      hooks/
        use-dashboard-data.ts
      lib/
        dto.ts
    example/
      backend/
        error.ts
        route.ts
        schema.ts
        service.ts
      components/
        example-status.tsx
      hooks/
        useExampleQuery.ts
      lib/
        dto.ts
    landing/
      components/
        cta-button.tsx
        cta-section.tsx
        features-section.tsx
        footer.tsx
        header.tsx
        hero-section.tsx
        mobile-menu.tsx
        pricing-section.tsx
    subscription/
      backend/
        billing-callback.ts
        error.ts
        route.ts
        schema.ts
        service.ts
        webhook.ts
      components/
        cancel-button.tsx
        cancel-modal.tsx
        expired-view.tsx
        free-view.tsx
        payment-history-list.tsx
        payment-method-card.tsx
        pro-active-view.tsx
        pro-canceled-view.tsx
        resume-button.tsx
        resume-modal.tsx
        subscribe-button.tsx
        subscription-content.tsx
        subscription-info-card.tsx
        usage-info-card.tsx
      context/
        subscription-context.tsx
      lib/
        dto.ts
  hooks/
    use-api-client.ts
    use-toast.ts
  lib/
    payment/
      toss.ts
    query/
      config.ts
      hooks.ts
    remote/
      api-client.ts
      types.ts
    supabase/
      browser-client.ts
      client.ts
      server-client.ts
      server.ts
      types.ts
    utils/
      date.ts
    validation/
      schemas.ts
    utils.ts
  stores/
    loading.ts
supabase/
  migrations/
    0001_create_example_table.sql
    0002_create_users_table.sql
    0003_create_subscriptions_table.sql
    0004_create_analyses_table.sql
    0005_create_payment_histories_table.sql
    0006_add_triggers.sql
.cursorignore
.gitignore
.vercel-redeploy
components.json
eslint.config.mjs
middleware.ts
next.config.ts
package.json
postcss.config.mjs
tailwind.config.ts
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/features/subscription/backend/billing-callback.ts">
import type { Hono } from 'hono';
import type { AppEnv } from '@/backend/hono/context';
import { requireAuth } from '@/backend/middleware/auth';
import { createProSubscription } from './service';

/**
 * Toss Payments 빌링 인증 콜백 라우트
 */
export const registerBillingCallbackRoutes = (app: Hono<AppEnv>) => {
  /**
   * 결제 성공 콜백
   * Toss Payments에서 빌링 인증 성공 시 리다이렉트
   */
  app.get('/api/billing/success', requireAuth(), async (c) => {
    const userId = c.get('userId')!;
    const supabase = c.get('supabase');
    const config = c.get('config');

    // 쿼리 파라미터에서 authKey, customerKey 추출
    const authKey = c.req.query('authKey');
    const customerKey = c.req.query('customerKey');

    // 필수 파라미터 검증
    if (!authKey || !customerKey) {
      return c.redirect(
        `/subscription?status=error&message=${encodeURIComponent('인증 정보가 누락되었습니다')}`
      );
    }

    // 보안 검증: customerKey가 현재 로그인한 사용자와 일치하는지 확인
    if (customerKey !== userId) {
      return c.redirect(
        `/subscription?status=error&message=${encodeURIComponent('인증 정보가 일치하지 않습니다')}`
      );
    }

    try {
      // 빌링키 발급 및 구독 생성
      await createProSubscription(
        supabase,
        userId,
        authKey,
        config.toss.secretKey
      );

      // 성공 시 구독 페이지로 리다이렉트
      return c.redirect('/subscription?status=success');
    } catch (error: any) {
      const errorMessage = error.message || '구독 처리 중 오류가 발생했습니다';
      return c.redirect(
        `/subscription?status=error&message=${encodeURIComponent(errorMessage)}`
      );
    }
  });

  /**
   * 결제 실패 콜백
   * Toss Payments에서 빌링 인증 실패 시 리다이렉트
   */
  app.get('/api/billing/fail', async (c) => {
    // Toss Payments에서 전달하는 에러 정보
    const code = c.req.query('code');
    const message = c.req.query('message');

    const errorMessage = message || '결제 인증에 실패했습니다';

    return c.redirect(
      `/subscription?status=fail&message=${encodeURIComponent(errorMessage)}`
    );
  });
};
</file>

<file path=".claude/settings.local.json">
{
  "permissions": {
    "allow": [
      "Bash(npm install:*)",
      "Bash(git add:*)",
      "Bash(git commit:*)",
      "Bash(git push:*)",
      "Bash(xargs file:*)",
      "Bash(cat:*)",
      "Bash(npm run build:*)",
      "Bash(node --version:*)",
      "Bash(npm run dev:*)"
    ],
    "deny": [],
    "ask": []
  }
}
</file>

<file path=".ruler/ruler.toml">
# Ruler Configuration File
# See https://ai.intellectronica.net/ruler for documentation.

# To specify which agents are active by default when --agents is not used,
# uncomment and populate the following line. If omitted, all agents are active.
default_agents = ["cursor", "claude"]

# Enable nested rule loading from nested .ruler directories
# When enabled, ruler will search for and process .ruler directories throughout the project hierarchy
# nested = false

# --- Agent Specific Configurations ---
# You can enable/disable agents and override their default output paths here.
# Use lowercase agent identifiers: amp, copilot, claude, codex, cursor, windsurf, cline, aider, kilocode

# [agents.copilot]
# enabled = true
# output_path = ".github/copilot-instructions.md"

# [agents.aider]
# enabled = true
# output_path_instructions = "AGENTS.md"
# output_path_config = ".aider.conf.yml"

# [agents.gemini-cli]
# enabled = true

# --- MCP Servers ---
# Define Model Context Protocol servers here. Two examples:
# 1. A stdio server (local executable)
# 2. A remote server (HTTP-based)

# [mcp_servers.example_stdio]
# command = "node"
# args = ["scripts/your-mcp-server.js"]
# env = { API_KEY = "replace_me" }

# [mcp_servers.example_remote]
# url = "https://api.example.com/mcp"
# headers = { Authorization = "Bearer REPLACE_ME" }
</file>

<file path="src/app/(protected)/analysis/[id]/page.tsx">
'use client';

import { use } from 'react';
import { useRouter } from 'next/navigation';
import { Loader2 } from 'lucide-react';
import { useAnalysisDetail } from '@/features/analysis/hooks/use-analysis-detail';
import { getAnalysisErrorType } from '@/features/analysis/lib/error';
import { AnalysisHeader } from '@/features/analysis/components/analysis-header';
import { ResultSection } from '@/features/analysis/components/result-section';
import { ActionButtons } from '@/features/analysis/components/action-buttons';
import { ErrorPage } from '@/features/analysis/components/error-page';
import { APP_CONFIG } from '@/constants/app';

interface PageProps {
  params: Promise<{ id: string }>;
}

export default function AnalysisDetailPage({ params }: PageProps) {
  const router = useRouter();
  const { id } = use(params);

  const { data, isLoading, isError, error, refetch } = useAnalysisDetail(id);

  // 로딩 상태
  if (isLoading) {
    return (
      <div className="container mx-auto py-16 flex flex-col items-center justify-center">
        <Loader2 className="h-8 w-8 animate-spin text-primary mb-4" />
        <p className="text-muted-foreground">분석 결과를 불러오는 중...</p>
      </div>
    );
  }

  // 에러 상태
  if (isError) {
    const errorType = getAnalysisErrorType(error);

    switch (errorType) {
      case 'forbidden':
        return (
          <ErrorPage
            title="접근 권한 없음"
            message="본인의 분석 결과만 조회할 수 있습니다."
            action={{
              label: '대시보드로',
              onClick: () => router.push(APP_CONFIG.routes.dashboard),
            }}
          />
        );

      case 'not-found':
        return (
          <ErrorPage
            title="분석을 찾을 수 없습니다"
            message="요청하신 분석 결과가 존재하지 않습니다."
            action={{
              label: '대시보드로',
              onClick: () => router.push(APP_CONFIG.routes.dashboard),
            }}
          />
        );

      case 'network':
        return (
          <ErrorPage
            title="네트워크 오류"
            message="분석 결과를 불러오는 중 오류가 발생했습니다."
            action={{
              label: '다시 시도',
              onClick: () => refetch(),
            }}
          />
        );

      default:
        return (
          <ErrorPage
            title="오류 발생"
            message="분석 결과를 불러올 수 없습니다. 잠시 후 다시 시도해주세요."
            action={{
              label: '대시보드로',
              onClick: () => router.push(APP_CONFIG.routes.dashboard),
            }}
          />
        );
    }
  }

  // 정상 상태: 분석 결과 표시
  if (!data) {
    return null;
  }

  const analysis = data.analysis;

  return (
    <div className="container mx-auto py-8 max-w-4xl space-y-8">
      <AnalysisHeader analysis={analysis} />

      <ResultSection title="사주팔자 기본 구성" data={analysis.result.basic} />
      <ResultSection title="성격 및 기질" data={analysis.result.personality} />
      <ResultSection
        title="대운·세운 분석"
        data={{
          대운: analysis.result.fortune.대운,
          세운: analysis.result.fortune.세운,
        }}
      />
      <ResultSection
        title="운세 종합"
        data={{
          직업운: analysis.result.fortune.직업운,
          재물운: analysis.result.fortune.재물운,
          건강운: analysis.result.fortune.건강운,
          연애운: analysis.result.fortune.연애운,
          대인관계운: analysis.result.fortune.대인관계운,
        }}
      />
      <ResultSection title="조언 및 제안" data={analysis.result.advice} />

      <ActionButtons
        onBackToDashboard={() => router.push(APP_CONFIG.routes.dashboard)}
      />
    </div>
  );
}
</file>

<file path="src/app/(protected)/analysis/new/page.tsx">
'use client';

import { AnalysisNewProvider } from '@/features/analysis/context/analysis-new-context';
import { AnalysisNewPage } from '@/features/analysis/components/analysis-new-page';

/**
 * 새 분석하기 페이지 엔트리
 */
export default function AnalysisNew() {
  return (
    <AnalysisNewProvider>
      <AnalysisNewPage />
    </AnalysisNewProvider>
  );
}
</file>

<file path="src/app/api/[[...hono]]/route.ts">
import { handle } from 'hono/vercel';
import { createHonoApp } from '@/backend/hono/app';

const app = createHonoApp();

export const GET = handle(app);
export const POST = handle(app);
export const PUT = handle(app);
export const PATCH = handle(app);
export const DELETE = handle(app);
export const OPTIONS = handle(app);

export const runtime = 'nodejs';
</file>

<file path="src/app/example/page.tsx">
'use client';

import { ExampleStatus } from '@/features/example/components/example-status';

export default function ExamplePage() {
  return (
    <div className="min-h-screen bg-gradient-to-b from-slate-950 via-slate-900 to-slate-950 px-6 py-16 text-slate-100">
      <ExampleStatus />
    </div>
  );
}
</file>

<file path="src/app/sign-in/[[...sign-in]]/page.tsx">
"use client";

import { SignIn } from "@clerk/nextjs";

export default function SignInPage() {
  return (
    <div className="flex min-h-screen items-center justify-center bg-gradient-to-br from-purple-50 via-white to-blue-50">
      <div className="w-full max-w-md px-4">
        <div className="mb-8 text-center">
          <h1 className="text-3xl font-bold text-gray-900">
            AI 사주 분석에 오신 것을 환영합니다
          </h1>
          <p className="mt-2 text-gray-600">
            로그인하여 개인화된 사주 분석을 시작하세요
          </p>
        </div>
        <SignIn
          appearance={{
            elements: {
              rootBox: "mx-auto",
              card: "shadow-xl",
            },
          }}
          routing="path"
          path="/sign-in"
          signUpUrl="/sign-up"
          afterSignInUrl="/dashboard"
        />
      </div>
    </div>
  );
}
</file>

<file path="src/app/sign-up/[[...sign-up]]/page.tsx">
"use client";

import { SignUp } from "@clerk/nextjs";

export default function SignUpPage() {
  return (
    <div className="flex min-h-screen items-center justify-center bg-gradient-to-br from-purple-50 via-white to-blue-50">
      <div className="w-full max-w-md px-4">
        <div className="mb-8 text-center">
          <h1 className="text-3xl font-bold text-gray-900">
            AI 사주 분석 시작하기
          </h1>
          <p className="mt-2 text-gray-600">
            무료로 가입하고 첫 사주 분석을 받아보세요
          </p>
        </div>
        <SignUp
          appearance={{
            elements: {
              rootBox: "mx-auto",
              card: "shadow-xl",
            },
          }}
          routing="path"
          path="/sign-up"
          signInUrl="/sign-in"
          afterSignUpUrl="/dashboard"
        />
      </div>
    </div>
  );
}
</file>

<file path="src/app/subscription/page.tsx">
'use client';

import { Suspense, useEffect } from 'react';
import { useSearchParams, useRouter } from 'next/navigation';
import { Loader2 } from 'lucide-react';
import { SubscriptionProvider } from '@/features/subscription/context/subscription-context';
import { SubscriptionContent } from '@/features/subscription/components/subscription-content';
import { toast } from '@/hooks/use-toast';

function PaymentStatusHandler() {
  const searchParams = useSearchParams();
  const router = useRouter();

  useEffect(() => {
    const status = searchParams.get('status');
    const message = searchParams.get('message');

    if (status === 'success') {
      toast({
        title: '구독 성공',
        description: 'Pro 구독이 시작되었습니다',
      });
      // URL에서 쿼리 파라미터 제거
      router.replace('/subscription');
    } else if (status === 'error') {
      toast({
        title: '구독 실패',
        description: message || '구독 처리 중 오류가 발생했습니다',
        variant: 'destructive',
      });
      // URL에서 쿼리 파라미터 제거
      router.replace('/subscription');
    } else if (status === 'fail') {
      toast({
        title: '결제 인증 실패',
        description: message || '결제 인증에 실패했습니다',
        variant: 'destructive',
      });
      // URL에서 쿼리 파라미터 제거
      router.replace('/subscription');
    }
  }, [searchParams, router]);

  return null;
}

export default function SubscriptionPage() {
  return (
    <SubscriptionProvider>
      <Suspense fallback={
        <div className="flex items-center justify-center min-h-screen">
          <Loader2 className="h-8 w-8 animate-spin text-muted-foreground" />
        </div>
      }>
        <PaymentStatusHandler />
      </Suspense>
      <SubscriptionContent />
    </SubscriptionProvider>
  );
}
</file>

<file path="src/backend/errors/codes.ts">
/**
 * 공통 에러 코드 정의
 *
 * 전체 애플리케이션에서 사용할 표준 에러 코드를 정의합니다.
 * Feature별로 고유한 에러 코드가 필요한 경우 해당 feature의 backend/error.ts에 정의하세요.
 */

export const CommonErrorCode = {
  // 인증 (4xx)
  UNAUTHORIZED: 'UNAUTHORIZED',
  FORBIDDEN: 'FORBIDDEN',
  SESSION_EXPIRED: 'SESSION_EXPIRED',

  // 검증 (4xx)
  INVALID_INPUT: 'INVALID_INPUT',
  VALIDATION_ERROR: 'VALIDATION_ERROR',

  // 리소스 (4xx)
  NOT_FOUND: 'NOT_FOUND',
  CONFLICT: 'CONFLICT',

  // 서버 (5xx)
  INTERNAL_ERROR: 'INTERNAL_ERROR',
  DATABASE_ERROR: 'DATABASE_ERROR',
  EXTERNAL_API_ERROR: 'EXTERNAL_API_ERROR',
} as const;

export type CommonErrorCode =
  (typeof CommonErrorCode)[keyof typeof CommonErrorCode];

/**
 * 에러 코드와 HTTP 상태 코드 매핑
 */
export const ErrorCodeToHttpStatus: Record<CommonErrorCode, number> = {
  [CommonErrorCode.UNAUTHORIZED]: 401,
  [CommonErrorCode.FORBIDDEN]: 403,
  [CommonErrorCode.SESSION_EXPIRED]: 401,
  [CommonErrorCode.INVALID_INPUT]: 400,
  [CommonErrorCode.VALIDATION_ERROR]: 400,
  [CommonErrorCode.NOT_FOUND]: 404,
  [CommonErrorCode.CONFLICT]: 409,
  [CommonErrorCode.INTERNAL_ERROR]: 500,
  [CommonErrorCode.DATABASE_ERROR]: 500,
  [CommonErrorCode.EXTERNAL_API_ERROR]: 502,
};
</file>

<file path="src/backend/integrations/gemini/client.ts">
import { GoogleGenerativeAI } from '@google/generative-ai';

/**
 * Gemini API 클라이언트
 *
 * Google Gemini AI를 사용한 사주 분석 기능을 제공합니다.
 */

export type GeminiModel = 'gemini-2.5-flash' | 'gemini-2.5-pro';

export interface GeminiAnalysisRequest {
  birthDate: Date;
  birthTime?: string;
  isLunar: boolean;
  gender: 'male' | 'female';
}

export interface GeminiAnalysisResult {
  basic: {
    천간지지: string;
    오행분석: string;
  };
  personality: {
    특성: string;
    장단점: string;
  };
  fortune: {
    대운: string;
    세운: string;
    직업운: string;
    재물운: string;
    건강운: string;
    연애운: string;
    대인관계운: string;
  };
  advice: {
    긍정적방향: string;
    주의점: string;
  };
}

/**
 * Gemini API 호출 (재시도 포함)
 *
 * @param request 사주 분석 요청 정보
 * @param model 사용할 모델 (Flash 또는 Pro)
 * @param apiKey Gemini API 키
 * @returns 분석 결과
 * @throws {Error} API 호출 실패 또는 할당량 초과 시
 */
export async function callGeminiAnalysis(
  request: GeminiAnalysisRequest,
  model: GeminiModel,
  apiKey: string
): Promise<GeminiAnalysisResult> {
  const genAI = new GoogleGenerativeAI(apiKey);
  const modelInstance = genAI.getGenerativeModel({ model });

  // 프롬프트 생성
  const prompt = buildSajuPrompt(request);

  // 재시도 로직 (최대 3회, 지수 백오프)
  let lastError: Error | null = null;
  const maxRetries = 3;

  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      const result = await modelInstance.generateContent(prompt);
      const response = await result.response;
      const text = response.text();

      // JSON 파싱 시도
      const analysisResult = parseGeminiResponse(text);
      return analysisResult;
    } catch (error) {
      lastError = error as Error;

      // 할당량 초과 에러 (429)는 재시도하지 않음
      if (lastError.message && lastError.message.includes('429')) {
        throw new Error(
          'API_QUOTA_EXCEEDED: Gemini API 할당량이 초과되었습니다'
        );
      }

      // 마지막 시도가 아니면 대기 후 재시도
      if (attempt < maxRetries) {
        const waitTime = Math.min(1000 * 2 ** (attempt - 1), 3000);
        await new Promise((resolve) => setTimeout(resolve, waitTime));
      }
    }
  }

  throw new Error(
    `EXTERNAL_API_ERROR: Gemini API 호출 실패 (${maxRetries}회 시도): ${lastError?.message}`
  );
}

/**
 * 사주 분석 프롬프트 생성
 */
function buildSajuPrompt(request: GeminiAnalysisRequest): string {
  const { birthDate, birthTime, isLunar, gender } = request;

  const year = birthDate.getFullYear();
  const month = birthDate.getMonth() + 1;
  const day = birthDate.getDate();
  const calendar = isLunar ? '음력' : '양력';
  const genderText = gender === 'male' ? '남성' : '여성';
  const timeText = birthTime || '시간 모름';

  return `
당신은 전문 사주 명리학자입니다. 다음 정보를 바탕으로 사주팔자 분석을 해주세요.

생년월일: ${year}년 ${month}월 ${day}일 (${calendar})
출생 시간: ${timeText}
성별: ${genderText}

다음 형식의 JSON으로 응답해주세요:

{
  "basic": {
    "천간지지": "천간과 지지를 포함한 사주팔자 구성 설명",
    "오행분석": "오행의 균형과 강약 분석"
  },
  "personality": {
    "특성": "타고난 성격과 기질 설명",
    "장단점": "성격의 장점과 단점 분석"
  },
  "fortune": {
    "대운": "현재 대운 흐름과 영향",
    "세운": "올해 세운 분석",
    "직업운": "적합한 직업과 커리어 방향",
    "재물운": "재물 운세 및 재테크 조언",
    "건강운": "건강 상태 및 주의사항",
    "연애운": "연애 및 결혼운 분석",
    "대인관계운": "대인관계 및 사회생활 운세"
  },
  "advice": {
    "긍정적방향": "앞으로 나아갈 긍정적인 방향과 조언",
    "주의점": "주의해야 할 사항과 개선 방향"
  }
}

JSON 형식만 응답하고, 다른 설명은 포함하지 마세요.
`.trim();
}

/**
 * Gemini 응답 파싱
 */
function parseGeminiResponse(text: string): GeminiAnalysisResult {
  try {
    // JSON 블록 추출 (마크다운 코드 블록 제거)
    let jsonText = text.trim();
    if (jsonText.startsWith('```json')) {
      jsonText = jsonText.replace(/^```json\s*/, '').replace(/\s*```$/, '');
    } else if (jsonText.startsWith('```')) {
      jsonText = jsonText.replace(/^```\s*/, '').replace(/\s*```$/, '');
    }

    const result = JSON.parse(jsonText) as GeminiAnalysisResult;

    // 필수 필드 검증
    if (
      !result.basic ||
      !result.personality ||
      !result.fortune ||
      !result.advice
    ) {
      throw new Error('Invalid response structure');
    }

    return result;
  } catch (error) {
    throw new Error(
      `Failed to parse Gemini response: ${(error as Error).message}`
    );
  }
}
</file>

<file path="src/backend/integrations/tosspayments/client.ts">
import axios from 'axios';
import * as crypto from 'crypto';

/**
 * 토스페이먼츠 API 클라이언트
 *
 * 빌링키 발급, 정기결제 승인, Webhook 검증 기능을 제공합니다.
 */

const TOSS_API_BASE_URL = 'https://api.tosspayments.com/v1';

export const TOSS_CONSTANTS = {
  PRO_PRICE: 3900,
  ORDER_NAME: 'Pro 구독 (월 3,900원)',
} as const;

/**
 * 빌링키 발급
 *
 * @param authKey 카드 인증 키 (결제창에서 받은 값)
 * @param customerKey 고객 고유 키 (사용자 ID)
 * @param secretKey 토스페이먼츠 시크릿 키
 * @returns 빌링키 및 고객 키
 */
export async function issueBillingKey(
  authKey: string,
  customerKey: string,
  secretKey: string
): Promise<{ billingKey: string; customerKey: string }> {
  const url = `${TOSS_API_BASE_URL}/billing/authorizations/issue`;

  try {
    const response = await axios.post(
      url,
      {
        authKey,
        customerKey,
      },
      {
        headers: {
          Authorization: `Basic ${Buffer.from(`${secretKey}:`).toString('base64')}`,
          'Content-Type': 'application/json',
        },
      }
    );

    const { billingKey, customerKey: returnedCustomerKey } = response.data;
    return { billingKey, customerKey: returnedCustomerKey };
  } catch (error) {
    if (axios.isAxiosError(error)) {
      const message = error.response?.data?.message || error.message;
      throw new Error(`Billing key issuance failed: ${message}`);
    }
    throw error;
  }
}

/**
 * 정기결제 승인
 *
 * @param billingKey 빌링키
 * @param amount 결제 금액
 * @param orderId 주문 ID (고유값)
 * @param orderName 주문명
 * @param secretKey 토스페이먼츠 시크릿 키
 * @returns 결제 키 및 승인 시각
 */
export async function approveBilling(
  billingKey: string,
  amount: number,
  orderId: string,
  orderName: string,
  secretKey: string
): Promise<{ paymentKey: string; approvedAt: Date }> {
  const url = `${TOSS_API_BASE_URL}/billing/${billingKey}`;

  try {
    const response = await axios.post(
      url,
      {
        amount,
        orderId,
        orderName,
        customerEmail: undefined, // 선택사항
      },
      {
        headers: {
          Authorization: `Basic ${Buffer.from(`${secretKey}:`).toString('base64')}`,
          'Content-Type': 'application/json',
        },
      }
    );

    const { paymentKey, approvedAt } = response.data;
    return { paymentKey, approvedAt: new Date(approvedAt) };
  } catch (error) {
    if (axios.isAxiosError(error)) {
      const message = error.response?.data?.message || error.message;
      throw new Error(`Billing approval failed: ${message}`);
    }
    throw error;
  }
}

/**
 * 빌링키 삭제
 *
 * @param billingKey 빌링키
 * @param secretKey 토스페이먼츠 시크릿 키
 */
export async function deleteBillingKey(
  billingKey: string,
  secretKey: string
): Promise<void> {
  const url = `${TOSS_API_BASE_URL}/billing/authorizations/${billingKey}`;

  try {
    await axios.delete(url, {
      headers: {
        Authorization: `Basic ${Buffer.from(`${secretKey}:`).toString('base64')}`,
      },
    });
  } catch (error) {
    if (axios.isAxiosError(error)) {
      const message = error.response?.data?.message || error.message;
      throw new Error(`Billing key deletion failed: ${message}`);
    }
    throw error;
  }
}

/**
 * Webhook 서명 검증
 *
 * 토스페이먼츠 Webhook의 서명을 검증하여 요청이 정당한지 확인합니다.
 *
 * @param payload Webhook 페이로드 (문자열)
 * @param signature Webhook 헤더의 서명 값
 * @param webhookSecret Webhook 시크릿 키
 * @returns 서명이 유효하면 true
 */
export function verifyWebhookSignature(
  payload: string,
  signature: string,
  webhookSecret: string
): boolean {
  const hmac = crypto.createHmac('sha256', webhookSecret);
  hmac.update(payload);
  const expectedSignature = hmac.digest('hex');

  return signature === expectedSignature;
}
</file>

<file path="src/backend/middleware/error.ts">
import { createMiddleware } from 'hono/factory';
import { match, P } from 'ts-pattern';
import {
  contextKeys,
  type AppEnv,
  type AppLogger,
} from '@/backend/hono/context';

export const errorBoundary = () =>
  createMiddleware<AppEnv>(async (c, next) => {
    try {
      await next();
    } catch (error) {
      const logger = c.get(contextKeys.logger) as AppLogger | undefined;
      const message = match(error)
        .with(P.instanceOf(Error), (err) => err.message)
        .otherwise(() => 'Unexpected error');

      logger?.error?.(error);

      return c.json(
        {
          error: {
            code: 'INTERNAL_SERVER_ERROR',
            message,
          },
        },
        500,
      );
    }
  });
</file>

<file path="src/backend/middleware/supabase.ts">
import { createMiddleware } from 'hono/factory';
import {
  contextKeys,
  type AppEnv,
} from '@/backend/hono/context';
import { createServiceClient } from '@/backend/supabase/client';

export const withSupabase = () =>
  createMiddleware<AppEnv>(async (c, next) => {
    const config = c.get(
      contextKeys.config,
    ) as AppEnv['Variables']['config'] | undefined;

    if (!config) {
      throw new Error('Application configuration is not available.');
    }

    const client = createServiceClient(config.supabase);

    c.set(contextKeys.supabase, client);

    await next();
  });
</file>

<file path="src/backend/services/usage.ts">
import type { SupabaseClient } from '@supabase/supabase-js';
import { startOfMonth, endOfMonth } from 'date-fns';

/**
 * 사용량 관리 유틸리티
 *
 * 분석 사용량 체크 및 제한 로직을 제공합니다.
 */

export interface UsageInfo {
  used: number;
  limit: number;
  remaining: number;
  nextResetDate?: Date;
  subscriptionTier: 'free' | 'pro';
}

/**
 * 사용 가능 여부 및 정보 조회
 *
 * @param supabase Supabase 클라이언트
 * @param userId 사용자 UUID
 * @returns 사용량 정보
 */
export async function checkUsageLimit(
  supabase: SupabaseClient,
  userId: string
): Promise<UsageInfo> {
  // 1. 사용자 구독 정보 조회
  const { data: user, error: userError } = await supabase
    .from('users')
    .select('subscription_tier')
    .eq('id', userId)
    .single();

  if (userError || !user) {
    throw new Error('User not found');
  }

  const tier = user.subscription_tier as 'free' | 'pro';

  if (tier === 'free') {
    // 무료 유저: 전체 기간 1회 제한
    const { count, error } = await supabase
      .from('analyses')
      .select('*', { count: 'exact', head: true })
      .eq('user_id', userId);

    if (error) {
      throw new Error('Failed to check usage');
    }

    const used = count ?? 0;
    const limit = 1;

    return {
      used,
      limit,
      remaining: Math.max(0, limit - used),
      subscriptionTier: 'free',
    };
  } else {
    // Pro 유저: 구독 시작일 기준 월별 10회 제한
    const { data: subscription, error: subError } = await supabase
      .from('subscriptions')
      .select('started_at')
      .eq('user_id', userId)
      .eq('plan', 'pro')
      .in('status', ['active', 'canceled'])
      .single();

    if (subError || !subscription) {
      throw new Error('Subscription not found');
    }

    const startedAt = new Date(subscription.started_at);
    const now = new Date();

    // 구독 시작일 기준으로 이번 달 시작/끝 날짜 계산
    const monthStart = startOfMonth(now);
    const monthEnd = endOfMonth(now);

    // 이번 달 사용량 조회
    const { count, error } = await supabase
      .from('analyses')
      .select('*', { count: 'exact', head: true })
      .eq('user_id', userId)
      .gte('created_at', monthStart.toISOString())
      .lt('created_at', monthEnd.toISOString());

    if (error) {
      throw new Error('Failed to check usage');
    }

    const used = count ?? 0;
    const limit = 10;

    // 다음 초기화 날짜 (다음 달 1일)
    const nextReset = new Date(monthEnd);
    nextReset.setDate(nextReset.getDate() + 1);

    return {
      used,
      limit,
      remaining: Math.max(0, limit - used),
      nextResetDate: nextReset,
      subscriptionTier: 'pro',
    };
  }
}

/**
 * 사용량 체크 및 차감
 *
 * 트랜잭션 내에서 호출되어야 합니다.
 * 사용 가능 횟수가 없으면 에러를 throw합니다.
 *
 * @param tx Supabase 클라이언트 (트랜잭션용)
 * @param userId 사용자 UUID
 * @throws {Error} 사용량 초과 시
 */
export async function consumeUsage(
  tx: SupabaseClient,
  userId: string
): Promise<void> {
  const usage = await checkUsageLimit(tx, userId);

  if (usage.remaining === 0) {
    throw new Error('USAGE_LIMIT_EXCEEDED');
  }

  // 실제 사용량 차감은 analyses 테이블에 INSERT하는 것으로 자동 처리됨
  // (COUNT 기반으로 계산하므로 별도 차감 로직 불필요)
}
</file>

<file path="src/backend/supabase/client.ts">
import { createClient } from '@supabase/supabase-js';
import type { SupabaseClient } from '@supabase/supabase-js';

export type ServiceClientConfig = {
  url: string;
  serviceRoleKey: string;
};

export const createServiceClient = ({
  url,
  serviceRoleKey,
}: ServiceClientConfig): SupabaseClient =>
  createClient(url, serviceRoleKey, {
    auth: {
      persistSession: false,
    },
  });
</file>

<file path="src/backend/supabase/helpers.ts">
import type { SupabaseClient } from '@supabase/supabase-js';

/**
 * 데이터베이스 헬퍼 유틸리티
 *
 * Supabase 쿼리 및 트랜잭션 공통 로직을 제공합니다.
 */

/**
 * 페이지네이션 파라미터
 */
export interface PaginationParams {
  page: number;
  limit: number;
}

/**
 * 페이지네이션 결과
 */
export interface PaginationResult<T> {
  data: T[];
  total: number;
  page: number;
  totalPages: number;
}

/**
 * 트랜잭션 실행
 *
 * Supabase는 네이티브 트랜잭션을 지원하지 않으므로,
 * 낙관적 동시성 제어 또는 FOR UPDATE를 사용하여 구현합니다.
 *
 * 주의: Supabase는 PostgreSQL 트랜잭션을 완전히 지원하지 않으므로,
 * 중요한 작업은 RPC 함수를 통해 서버 측에서 처리하는 것을 권장합니다.
 *
 * @example
 * ```ts
 * const result = await withTransaction(supabase, async (tx) => {
 *   // 사용량 체크 및 차감
 *   const { data: usage } = await tx.from('usage_records').select('*');
 *   await tx.from('usage_records').update({ count: usage.count + 1 });
 *   return usage;
 * });
 * ```
 */
export async function withTransaction<T>(
  supabase: SupabaseClient,
  callback: (tx: SupabaseClient) => Promise<T>
): Promise<T> {
  // Supabase는 클라이언트 측 트랜잭션을 지원하지 않으므로,
  // 동일한 클라이언트를 전달하고 에러 시 롤백은 애플리케이션 로직으로 처리
  // 실제 프로덕션에서는 RPC 함수를 통해 서버 측 트랜잭션을 사용하는 것이 안전함

  try {
    const result = await callback(supabase);
    return result;
  } catch (error) {
    // 롤백은 애플리케이션 레벨에서 처리 (Supabase 제한사항)
    throw error;
  }
}

/**
 * 페이지네이션 쿼리 헬퍼
 *
 * 주의: Supabase 타입 제한으로 인해 실제 사용 시 직접 페이지네이션 로직 구현 권장
 *
 * @example
 * ```ts
 * // 직접 사용 예시
 * const { data, count } = await supabase
 *   .from('analyses')
 *   .select('*', { count: 'exact' })
 *   .eq('user_id', userId)
 *   .range(offset, offset + limit - 1);
 * ```
 */
export async function paginateQuery<T>(
  supabase: SupabaseClient,
  tableName: string,
  params: PaginationParams,
  filter?: (query: any) => any
): Promise<PaginationResult<T>> {
  const { page, limit } = params;
  const offset = (page - 1) * limit;

  let query = supabase.from(tableName).select('*', { count: 'exact' });

  if (filter) {
    query = filter(query);
  }

  const { data, count, error } = await query.range(
    offset,
    offset + limit - 1
  );

  if (error) {
    throw transformSupabaseError(error);
  }

  const total = count ?? 0;
  const totalPages = Math.ceil(total / limit);

  return {
    data: (data as T[]) ?? [],
    total,
    page,
    totalPages,
  };
}

/**
 * Supabase 에러를 표준 에러로 변환
 *
 * @example
 * ```ts
 * try {
 *   await supabase.from('users').insert(data);
 * } catch (error) {
 *   const standardError = transformSupabaseError(error);
 *   throw standardError;
 * }
 * ```
 */
export function transformSupabaseError(error: unknown): Error {
  if (error instanceof Error) {
    return error;
  }

  if (typeof error === 'object' && error !== null) {
    const err = error as {
      message?: string;
      code?: string;
      details?: string;
    };

    const message = err.message || err.details || 'Database error occurred';
    return new Error(message);
  }

  return new Error('Unknown database error');
}

/**
 * 단일 레코드 조회 헬퍼 (존재하지 않으면 에러)
 *
 * 주의: 타입 안전성을 위해 직접 쿼리 작성 권장
 *
 * @example
 * ```ts
 * // 직접 사용 예시
 * const { data, error } = await supabase
 *   .from('users')
 *   .select('*')
 *   .eq('id', userId)
 *   .single();
 * ```
 */
export async function findOne<T = any>(
  supabase: SupabaseClient,
  tableName: string,
  filter: Record<string, any>
): Promise<T> {
  let query = supabase.from(tableName).select('*');

  Object.entries(filter).forEach(([key, value]) => {
    query = query.eq(key, value);
  });

  const { data, error } = await query.single();

  if (error) {
    throw transformSupabaseError(error);
  }

  if (!data) {
    throw new Error('Record not found');
  }

  return data as T;
}

/**
 * 레코드 존재 여부 확인
 *
 * @example
 * ```ts
 * const userExists = await exists(
 *   supabase,
 *   'users',
 *   { clerk_user_id: clerkUserId }
 * );
 * ```
 */
export async function exists(
  supabase: SupabaseClient,
  tableName: string,
  filter: Record<string, any>
): Promise<boolean> {
  let query = supabase.from(tableName).select('id', { count: 'exact', head: true });

  Object.entries(filter).forEach(([key, value]) => {
    query = query.eq(key, value);
  });

  const { count, error } = await query;

  if (error) {
    throw transformSupabaseError(error);
  }

  return (count ?? 0) > 0;
}
</file>

<file path="src/components/common/loading-overlay.tsx">
'use client';

import { useLoadingStore } from '@/stores/loading';

/**
 * 전역 로딩 오버레이
 *
 * 사용 예시:
 * ```tsx
 * import { useLoadingStore } from '@/stores/loading';
 *
 * const { startLoading, stopLoading } = useLoadingStore();
 *
 * const handleSubmit = async () => {
 *   startLoading('AI가 사주를 분석하고 있습니다...');
 *   try {
 *     await analysisMutation.mutateAsync(data);
 *   } finally {
 *     stopLoading();
 *   }
 * };
 * ```
 */
export function LoadingOverlay() {
  const { isLoading, message } = useLoadingStore();

  if (!isLoading) return null;

  return (
    <div className="fixed inset-0 bg-background/80 z-50 flex items-center justify-center">
      <div className="flex flex-col items-center gap-4">
        <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-primary" />
        {message && <p className="text-sm text-muted-foreground">{message}</p>}
      </div>
    </div>
  );
}
</file>

<file path="src/components/ui/accordion.tsx">
"use client"

import * as React from "react"
import * as AccordionPrimitive from "@radix-ui/react-accordion"
import { ChevronDown } from "lucide-react"

import { cn } from "@/lib/utils"

const Accordion = AccordionPrimitive.Root

const AccordionItem = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Item>
>(({ className, ...props }, ref) => (
  <AccordionPrimitive.Item
    ref={ref}
    className={cn("border-b", className)}
    {...props}
  />
))
AccordionItem.displayName = "AccordionItem"

const AccordionTrigger = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Header className="flex">
    <AccordionPrimitive.Trigger
      ref={ref}
      className={cn(
        "flex flex-1 items-center justify-between py-4 font-medium transition-all hover:underline [&[data-state=open]>svg]:rotate-180",
        className
      )}
      {...props}
    >
      {children}
      <ChevronDown className="h-4 w-4 shrink-0 transition-transform duration-200" />
    </AccordionPrimitive.Trigger>
  </AccordionPrimitive.Header>
))
AccordionTrigger.displayName = AccordionPrimitive.Trigger.displayName

const AccordionContent = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Content
    ref={ref}
    className="overflow-hidden text-sm transition-all data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down"
    {...props}
  >
    <div className={cn("pb-4 pt-0", className)}>{children}</div>
  </AccordionPrimitive.Content>
))

AccordionContent.displayName = AccordionPrimitive.Content.displayName

export { Accordion, AccordionItem, AccordionTrigger, AccordionContent }
</file>

<file path="src/components/ui/alert.tsx">
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const alertVariants = cva(
  "relative w-full rounded-lg border p-4 [&>svg~*]:pl-7 [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground",
  {
    variants: {
      variant: {
        default: "bg-background text-foreground",
        destructive:
          "border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

const Alert = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & VariantProps<typeof alertVariants>
>(({ className, variant, ...props }, ref) => (
  <div
    ref={ref}
    role="alert"
    className={cn(alertVariants({ variant }), className)}
    {...props}
  />
))
Alert.displayName = "Alert"

const AlertTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h5
    ref={ref}
    className={cn("mb-1 font-medium leading-none tracking-tight", className)}
    {...props}
  />
))
AlertTitle.displayName = "AlertTitle"

const AlertDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm [&_p]:leading-relaxed", className)}
    {...props}
  />
))
AlertDescription.displayName = "AlertDescription"

export { Alert, AlertTitle, AlertDescription }
</file>

<file path="src/components/ui/avatar.tsx">
"use client"

import * as React from "react"
import * as AvatarPrimitive from "@radix-ui/react-avatar"

import { cn } from "@/lib/utils"

const Avatar = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex h-10 w-10 shrink-0 overflow-hidden rounded-full",
      className
    )}
    {...props}
  />
))
Avatar.displayName = AvatarPrimitive.Root.displayName

const AvatarImage = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Image>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Image>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Image
    ref={ref}
    className={cn("aspect-square h-full w-full", className)}
    {...props}
  />
))
AvatarImage.displayName = AvatarPrimitive.Image.displayName

const AvatarFallback = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Fallback>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Fallback>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Fallback
    ref={ref}
    className={cn(
      "flex h-full w-full items-center justify-center rounded-full bg-muted",
      className
    )}
    {...props}
  />
))
AvatarFallback.displayName = AvatarPrimitive.Fallback.displayName

export { Avatar, AvatarImage, AvatarFallback }
</file>

<file path="src/components/ui/badge.tsx">
import * as React from "react";
import { cva, type VariantProps } from "class-variance-authority";

import { cn } from "@/lib/utils";

const badgeVariants = cva(
  "inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-hidden focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground hover:bg-primary/80",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive:
          "border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80",
        outline: "text-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  },
);

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
  return (
    <div className={cn(badgeVariants({ variant }), className)} {...props} />
  );
}

export { Badge, badgeVariants };
</file>

<file path="src/components/ui/button.tsx">
import * as React from "react";
import { Slot } from "@radix-ui/react-slot";
import { cva, type VariantProps } from "class-variance-authority";

import { cn } from "@/lib/utils";

const buttonVariants = cva(
  "inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-hidden focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline:
          "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  },
);

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean;
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button";
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    );
  },
);
Button.displayName = "Button";

export { Button, buttonVariants };
</file>

<file path="src/components/ui/card.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-lg border bg-card text-card-foreground shadow-xs",
      className
    )}
    {...props}
  />
))
Card.displayName = "Card"

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "text-2xl font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }
</file>

<file path="src/components/ui/checkbox.tsx">
"use client";

import * as React from "react";
import * as CheckboxPrimitive from "@radix-ui/react-checkbox";
import { Check } from "lucide-react";

import { cn } from "@/lib/utils";

const Checkbox = React.forwardRef<
  React.ElementRef<typeof CheckboxPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>
>(({ className, ...props }, ref) => (
  <CheckboxPrimitive.Root
    ref={ref}
    className={cn(
      "peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-hidden focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
      className,
    )}
    {...props}
  >
    <CheckboxPrimitive.Indicator
      className={cn("flex items-center justify-center text-current")}
    >
      <Check className="h-4 w-4" />
    </CheckboxPrimitive.Indicator>
  </CheckboxPrimitive.Root>
));
Checkbox.displayName = CheckboxPrimitive.Root.displayName;

export { Checkbox };
</file>

<file path="src/components/ui/dialog.tsx">
"use client"

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const Dialog = DialogPrimitive.Root

const DialogTrigger = DialogPrimitive.Trigger

const DialogPortal = DialogPrimitive.Portal

const DialogClose = DialogPrimitive.Close

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
  />
))
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
))
DialogContent.displayName = DialogPrimitive.Content.displayName

const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-1.5 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
DialogHeader.displayName = "DialogHeader"

const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
DialogFooter.displayName = "DialogFooter"

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
DialogTitle.displayName = DialogPrimitive.Title.displayName

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
DialogDescription.displayName = DialogPrimitive.Description.displayName

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogClose,
  DialogTrigger,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
}
</file>

<file path="src/components/ui/dropdown-menu.tsx">
"use client";

import * as React from "react";
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu";
import { Check, ChevronRight, Circle } from "lucide-react";

import { cn } from "@/lib/utils";

const DropdownMenu = DropdownMenuPrimitive.Root;

const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger;

const DropdownMenuGroup = DropdownMenuPrimitive.Group;

const DropdownMenuPortal = DropdownMenuPrimitive.Portal;

const DropdownMenuSub = DropdownMenuPrimitive.Sub;

const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup;

const DropdownMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
    inset?: boolean;
  }
>(({ className, inset, children, ...props }, ref) => (
  <DropdownMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-hidden focus:bg-accent data-[state=open]:bg-accent",
      inset && "pl-8",
      className,
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </DropdownMenuPrimitive.SubTrigger>
));
DropdownMenuSubTrigger.displayName =
  DropdownMenuPrimitive.SubTrigger.displayName;

const DropdownMenuSubContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-32 overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className,
    )}
    {...props}
  />
));
DropdownMenuSubContent.displayName =
  DropdownMenuPrimitive.SubContent.displayName;

const DropdownMenuContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <DropdownMenuPrimitive.Portal>
    <DropdownMenuPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 min-w-32 overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className,
      )}
      {...props}
    />
  </DropdownMenuPrimitive.Portal>
));
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName;

const DropdownMenuItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-hidden transition-colors focus:bg-accent focus:text-accent-foreground data-disabled:pointer-events-none data-disabled:opacity-50",
      inset && "pl-8",
      className,
    )}
    {...props}
  />
));
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName;

const DropdownMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <DropdownMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-hidden transition-colors focus:bg-accent focus:text-accent-foreground data-disabled:pointer-events-none data-disabled:opacity-50",
      className,
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.CheckboxItem>
));
DropdownMenuCheckboxItem.displayName =
  DropdownMenuPrimitive.CheckboxItem.displayName;

const DropdownMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <DropdownMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-hidden transition-colors focus:bg-accent focus:text-accent-foreground data-disabled:pointer-events-none data-disabled:opacity-50",
      className,
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.RadioItem>
));
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName;

const DropdownMenuLabel = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
    inset?: boolean;
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold",
      inset && "pl-8",
      className,
    )}
    {...props}
  />
));
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName;

const DropdownMenuSeparator = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
));
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName;

const DropdownMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn("ml-auto text-xs tracking-widest opacity-60", className)}
      {...props}
    />
  );
};
DropdownMenuShortcut.displayName = "DropdownMenuShortcut";

export {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuRadioGroup,
};
</file>

<file path="src/components/ui/file-upload.tsx">
"use client";

import { cn } from "@/lib/utils";
import { ChangeEvent, useRef } from "react";

interface FileUploadProps extends React.HTMLAttributes<HTMLDivElement> {
  onFileChange: (file: File) => void;
  accept?: string;
}

export function FileUpload({
  className,
  onFileChange,
  accept = "image/*",
  children,
  ...props
}: FileUploadProps) {
  const inputRef = useRef<HTMLInputElement>(null);

  const handleClick = () => {
    inputRef.current?.click();
  };

  const handleChange = (e: ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (file) {
      onFileChange(file);
    }
  };

  return (
    <div
      onClick={handleClick}
      className={cn(
        "cursor-pointer rounded-md border-2 border-dashed border-gray-300 p-4 hover:border-gray-400",
        className
      )}
      {...props}
    >
      <input
        type="file"
        ref={inputRef}
        onChange={handleChange}
        accept={accept}
        className="hidden"
      />
      {children}
    </div>
  );
}
</file>

<file path="src/components/ui/form.tsx">
'use client';

import * as React from 'react';
import * as LabelPrimitive from '@radix-ui/react-label';
import { Slot } from '@radix-ui/react-slot';
import {
  Controller,
  ControllerProps,
  FieldPath,
  FieldValues,
  FormProvider,
  useFormContext,
} from 'react-hook-form';

import { cn } from '@/lib/utils';
import { Label } from '@/components/ui/label';

const Form = FormProvider;

type FormFieldContextValue<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
> = {
  name: TName;
};

const FormFieldContext = React.createContext<FormFieldContextValue>(
  {} as FormFieldContextValue,
);

const FormField = <
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>,
>({
  ...props
}: ControllerProps<TFieldValues, TName>) => {
  return (
    <FormFieldContext.Provider value={{ name: props.name }}>
      <Controller {...props} />
    </FormFieldContext.Provider>
  );
};

const useFormField = () => {
  const fieldContext = React.useContext(FormFieldContext);
  const itemContext = React.useContext(FormItemContext);
  const { getFieldState, formState } = useFormContext();

  const fieldState = getFieldState(fieldContext.name, formState);

  if (!fieldContext) {
    throw new Error('useFormField should be used within <FormField>');
  }

  const { id } = itemContext;

  return {
    id,
    name: fieldContext.name,
    formItemId: `${id}-form-item`,
    formDescriptionId: `${id}-form-item-description`,
    formMessageId: `${id}-form-item-message`,
    ...fieldState,
  };
};

type FormItemContextValue = {
  id: string;
};

const FormItemContext = React.createContext<FormItemContextValue>(
  {} as FormItemContextValue,
);

const FormItem = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const id = React.useId();

  return (
    <FormItemContext.Provider value={{ id }}>
      <div ref={ref} className={cn('space-y-2', className)} {...props} />
    </FormItemContext.Provider>
  );
});
FormItem.displayName = 'FormItem';

const FormLabel = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root>
>(({ className, ...props }, ref) => {
  const { error, formItemId } = useFormField();

  return (
    <Label
      ref={ref}
      className={cn(error && 'text-destructive', className)}
      htmlFor={formItemId}
      {...props}
    />
  );
});
FormLabel.displayName = 'FormLabel';

const FormControl = React.forwardRef<
  React.ElementRef<typeof Slot>,
  React.ComponentPropsWithoutRef<typeof Slot>
>(({ ...props }, ref) => {
  const { error, formItemId, formDescriptionId, formMessageId } =
    useFormField();

  return (
    <Slot
      ref={ref}
      id={formItemId}
      aria-describedby={
        !error
          ? `${formDescriptionId}`
          : `${formDescriptionId} ${formMessageId}`
      }
      aria-invalid={!!error}
      {...props}
    />
  );
});
FormControl.displayName = 'FormControl';

const FormDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => {
  const { formDescriptionId } = useFormField();

  return (
    <p
      ref={ref}
      id={formDescriptionId}
      className={cn('text-sm text-muted-foreground', className)}
      {...props}
    />
  );
});
FormDescription.displayName = 'FormDescription';

const FormMessage = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, children, ...props }, ref) => {
  const { error, formMessageId } = useFormField();
  const body = error ? String(error?.message) : children;

  if (!body) {
    return null;
  }

  return (
    <p
      ref={ref}
      id={formMessageId}
      className={cn('text-sm font-medium text-destructive', className)}
      {...props}
    >
      {body}
    </p>
  );
});
FormMessage.displayName = 'FormMessage';

export {
  useFormField,
  Form,
  FormItem,
  FormLabel,
  FormControl,
  FormDescription,
  FormMessage,
  FormField,
};
</file>

<file path="src/components/ui/input.tsx">
import * as React from "react";

import { cn } from "@/lib/utils";

export interface InputProps
  extends React.InputHTMLAttributes<HTMLInputElement> {}

const Input = React.forwardRef<HTMLInputElement, InputProps>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-hidden focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
          className,
        )}
        ref={ref}
        {...props}
      />
    );
  },
);
Input.displayName = "Input";

export { Input };
</file>

<file path="src/components/ui/label.tsx">
"use client";

import * as React from "react";
import * as LabelPrimitive from "@radix-ui/react-label";
import { cva, type VariantProps } from "class-variance-authority";

import { cn } from "@/lib/utils";

const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70",
);

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
    VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  />
));
Label.displayName = LabelPrimitive.Root.displayName;

export { Label };
</file>

<file path="src/components/ui/progress.tsx">
"use client"

import * as React from "react"
import * as ProgressPrimitive from "@radix-ui/react-progress"

import { cn } from "@/lib/utils"

const Progress = React.forwardRef<
  React.ElementRef<typeof ProgressPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ProgressPrimitive.Root>
>(({ className, value, ...props }, ref) => (
  <ProgressPrimitive.Root
    ref={ref}
    className={cn(
      "relative h-4 w-full overflow-hidden rounded-full bg-secondary",
      className
    )}
    {...props}
  >
    <ProgressPrimitive.Indicator
      className="h-full w-full flex-1 bg-primary transition-all"
      style={{ transform: `translateX(-${100 - (value || 0)}%)` }}
    />
  </ProgressPrimitive.Root>
))
Progress.displayName = ProgressPrimitive.Root.displayName

export { Progress }
</file>

<file path="src/components/ui/radio-group.tsx">
"use client"

import * as React from "react"
import * as RadioGroupPrimitive from "@radix-ui/react-radio-group"
import { Circle } from "lucide-react"

import { cn } from "@/lib/utils"

const RadioGroup = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Root>
>(({ className, ...props }, ref) => {
  return (
    <RadioGroupPrimitive.Root
      className={cn("grid gap-2", className)}
      {...props}
      ref={ref}
    />
  )
})
RadioGroup.displayName = RadioGroupPrimitive.Root.displayName

const RadioGroupItem = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Item>
>(({ className, ...props }, ref) => {
  return (
    <RadioGroupPrimitive.Item
      ref={ref}
      className={cn(
        "aspect-square h-4 w-4 rounded-full border border-primary text-primary ring-offset-background focus:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <RadioGroupPrimitive.Indicator className="flex items-center justify-center">
        <Circle className="h-2.5 w-2.5 fill-current text-current" />
      </RadioGroupPrimitive.Indicator>
    </RadioGroupPrimitive.Item>
  )
})
RadioGroupItem.displayName = RadioGroupPrimitive.Item.displayName

export { RadioGroup, RadioGroupItem }
</file>

<file path="src/components/ui/select.tsx">
'use client';

import * as React from 'react';
import * as SelectPrimitive from '@radix-ui/react-select';
import { Check, ChevronDown, ChevronUp } from 'lucide-react';

import { cn } from '@/lib/utils';

const Select = SelectPrimitive.Root;

const SelectGroup = SelectPrimitive.Group;

const SelectValue = SelectPrimitive.Value;

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      'flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-hidden focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1',
      className,
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <ChevronDown className="h-4 w-4 opacity-50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
));
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName;

const SelectScrollUpButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn(
      'flex cursor-default items-center justify-center py-1',
      className,
    )}
    {...props}
  >
    <ChevronUp className="h-4 w-4" />
  </SelectPrimitive.ScrollUpButton>
));
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName;

const SelectScrollDownButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn(
      'flex cursor-default items-center justify-center py-1',
      className,
    )}
    {...props}
  >
    <ChevronDown className="h-4 w-4" />
  </SelectPrimitive.ScrollDownButton>
));
SelectScrollDownButton.displayName =
  SelectPrimitive.ScrollDownButton.displayName;

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = 'popper', ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        'relative z-50 max-h-96 min-w-32 overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2',
        position === 'popper' &&
          'data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1',
        className,
      )}
      position={position}
      {...props}
    >
      <SelectScrollUpButton />
      <SelectPrimitive.Viewport
        className={cn(
          'p-1',
          position === 'popper' &&
            'h-(--radix-select-trigger-height) w-full min-w-(--radix-select-trigger-width)',
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
      <SelectScrollDownButton />
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
));
SelectContent.displayName = SelectPrimitive.Content.displayName;

const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn('py-1.5 pl-8 pr-2 text-sm font-semibold', className)}
    {...props}
  />
));
SelectLabel.displayName = SelectPrimitive.Label.displayName;

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      'relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-hidden focus:bg-accent focus:text-accent-foreground data-disabled:pointer-events-none data-disabled:opacity-50',
      className,
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>

    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
));
SelectItem.displayName = SelectPrimitive.Item.displayName;

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn('-mx-1 my-1 h-px bg-muted', className)}
    {...props}
  />
));
SelectSeparator.displayName = SelectPrimitive.Separator.displayName;

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
  SelectScrollUpButton,
  SelectScrollDownButton,
};
</file>

<file path="src/components/ui/separator.tsx">
"use client"

import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"

import { cn } from "@/lib/utils"

const Separator = React.forwardRef<
  React.ElementRef<typeof SeparatorPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SeparatorPrimitive.Root>
>(
  (
    { className, orientation = "horizontal", decorative = true, ...props },
    ref
  ) => (
    <SeparatorPrimitive.Root
      ref={ref}
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "shrink-0 bg-border",
        orientation === "horizontal" ? "h-px w-full" : "h-full w-px",
        className
      )}
      {...props}
    />
  )
)
Separator.displayName = SeparatorPrimitive.Root.displayName

export { Separator }
</file>

<file path="src/components/ui/sheet.tsx">
'use client';

import * as React from 'react';
import * as SheetPrimitive from '@radix-ui/react-dialog';
import { cva, type VariantProps } from 'class-variance-authority';
import { X } from 'lucide-react';

import { cn } from '@/lib/utils';

const Sheet = SheetPrimitive.Root;

const SheetTrigger = SheetPrimitive.Trigger;

const SheetClose = SheetPrimitive.Close;

const SheetPortal = SheetPrimitive.Portal;

const SheetOverlay = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Overlay
    className={cn(
      'fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0',
      className,
    )}
    {...props}
    ref={ref}
  />
));
SheetOverlay.displayName = SheetPrimitive.Overlay.displayName;

const sheetVariants = cva(
  'fixed z-50 gap-4 bg-background p-6 shadow-lg transition ease-in-out data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:duration-300 data-[state=open]:duration-500',
  {
    variants: {
      side: {
        top: 'inset-x-0 top-0 border-b data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top',
        bottom:
          'inset-x-0 bottom-0 border-t data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom',
        left: 'inset-y-0 left-0 h-full w-3/4 border-r data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm',
        right:
          'inset-y-0 right-0 h-full w-3/4  border-l data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm',
      },
    },
    defaultVariants: {
      side: 'right',
    },
  },
);

interface SheetContentProps
  extends React.ComponentPropsWithoutRef<typeof SheetPrimitive.Content>,
    VariantProps<typeof sheetVariants> {}

const SheetContent = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Content>,
  SheetContentProps
>(({ side = 'right', className, children, ...props }, ref) => (
  <SheetPortal>
    <SheetOverlay />
    <SheetPrimitive.Content
      ref={ref}
      className={cn(sheetVariants({ side }), className)}
      {...props}
    >
      {children}
      <SheetPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-hidden focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-secondary">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </SheetPrimitive.Close>
    </SheetPrimitive.Content>
  </SheetPortal>
));
SheetContent.displayName = SheetPrimitive.Content.displayName;

const SheetHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      'flex flex-col space-y-2 text-center sm:text-left',
      className,
    )}
    {...props}
  />
);
SheetHeader.displayName = 'SheetHeader';

const SheetFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      'flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2',
      className,
    )}
    {...props}
  />
);
SheetFooter.displayName = 'SheetFooter';

const SheetTitle = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Title>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Title
    ref={ref}
    className={cn('text-lg font-semibold text-foreground', className)}
    {...props}
  />
));
SheetTitle.displayName = SheetPrimitive.Title.displayName;

const SheetDescription = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Description>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Description
    ref={ref}
    className={cn('text-sm text-muted-foreground', className)}
    {...props}
  />
));
SheetDescription.displayName = SheetPrimitive.Description.displayName;

export {
  Sheet,
  SheetPortal,
  SheetOverlay,
  SheetTrigger,
  SheetClose,
  SheetContent,
  SheetHeader,
  SheetFooter,
  SheetTitle,
  SheetDescription,
};
</file>

<file path="src/components/ui/skeleton.tsx">
import { cn } from "@/lib/utils"

function Skeleton({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div
      className={cn("animate-pulse rounded-md bg-muted", className)}
      {...props}
    />
  )
}

export { Skeleton }
</file>

<file path="src/components/ui/textarea.tsx">
import * as React from 'react';

import { cn } from '@/lib/utils';

const Textarea = React.forwardRef<
  HTMLTextAreaElement,
  React.ComponentProps<'textarea'>
>(({ className, ...props }, ref) => {
  return (
    <textarea
      className={cn(
        'flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background placeholder:text-muted-foreground focus-visible:outline-hidden focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm',
        className,
      )}
      ref={ref}
      {...props}
    />
  );
});
Textarea.displayName = 'Textarea';

export { Textarea };
</file>

<file path="src/components/ui/toast.tsx">
'use client';

import * as React from 'react';
import * as ToastPrimitives from '@radix-ui/react-toast';
import { cva, type VariantProps } from 'class-variance-authority';
import { X } from 'lucide-react';

import { cn } from '@/lib/utils';

const ToastProvider = ToastPrimitives.Provider;

const ToastViewport = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Viewport>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Viewport
    ref={ref}
    className={cn(
      'fixed top-0 z-100 flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]',
      className,
    )}
    {...props}
  />
));
ToastViewport.displayName = ToastPrimitives.Viewport.displayName;

const toastVariants = cva(
  'group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-(--radix-toast-swipe-end-x) data-[swipe=move]:translate-x-(--radix-toast-swipe-move-x) data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full',
  {
    variants: {
      variant: {
        default: 'border bg-background text-foreground',
        destructive:
          'destructive group border-destructive bg-destructive text-destructive-foreground',
      },
    },
    defaultVariants: {
      variant: 'default',
    },
  },
);

const Toast = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> &
    VariantProps<typeof toastVariants>
>(({ className, variant, ...props }, ref) => {
  return (
    <ToastPrimitives.Root
      ref={ref}
      className={cn(toastVariants({ variant }), className)}
      {...props}
    />
  );
});
Toast.displayName = ToastPrimitives.Root.displayName;

const ToastAction = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Action>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Action
    ref={ref}
    className={cn(
      'inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors hover:bg-secondary focus:outline-hidden focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 hover:group-[.destructive]:border-destructive/30 hover:group-[.destructive]:bg-destructive hover:group-[.destructive]:text-destructive-foreground focus:group-[.destructive]:ring-destructive',
      className,
    )}
    {...props}
  />
));
ToastAction.displayName = ToastPrimitives.Action.displayName;

const ToastClose = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Close>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Close
    ref={ref}
    className={cn(
      'absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-hidden focus:ring-2 group-hover:opacity-100 group-[.destructive]:text-red-300 hover:group-[.destructive]:text-red-50 focus:group-[.destructive]:ring-red-400 focus:group-[.destructive]:ring-offset-red-600',
      className,
    )}
    toast-close=""
    {...props}
  >
    <X className="h-4 w-4" />
  </ToastPrimitives.Close>
));
ToastClose.displayName = ToastPrimitives.Close.displayName;

const ToastTitle = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Title>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Title
    ref={ref}
    className={cn('text-sm font-semibold', className)}
    {...props}
  />
));
ToastTitle.displayName = ToastPrimitives.Title.displayName;

const ToastDescription = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Description>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Description
    ref={ref}
    className={cn('text-sm opacity-90', className)}
    {...props}
  />
));
ToastDescription.displayName = ToastPrimitives.Description.displayName;

type ToastProps = React.ComponentPropsWithoutRef<typeof Toast>;

type ToastActionElement = React.ReactElement<typeof ToastAction>;

export {
  type ToastProps,
  type ToastActionElement,
  ToastProvider,
  ToastViewport,
  Toast,
  ToastTitle,
  ToastDescription,
  ToastClose,
  ToastAction,
};
</file>

<file path="src/components/ui/toaster.tsx">
'use client';

import { useToast } from '@/hooks/use-toast';
import {
  Toast,
  ToastClose,
  ToastDescription,
  ToastProvider,
  ToastTitle,
  ToastViewport,
} from '@/components/ui/toast';

export function Toaster() {
  const { toasts } = useToast();

  return (
    <ToastProvider>
      {toasts.map(function ({ id, title, description, action, ...props }) {
        return (
          <Toast key={id} {...props}>
            <div className="grid gap-1">
              {title && <ToastTitle>{title}</ToastTitle>}
              {description && (
                <ToastDescription>{description}</ToastDescription>
              )}
            </div>
            {action}
            <ToastClose />
          </Toast>
        );
      })}
      <ToastViewport />
    </ToastProvider>
  );
}
</file>

<file path="src/constants/app.ts">
/**
 * 애플리케이션 전역 상수
 */

export const APP_CONFIG = {
  name: 'Mafia Saju',
  description: 'AI 기반 사주 분석 구독 서비스',

  subscription: {
    free: {
      tier: 'free' as const,
      name: '무료 체험',
      limit: 1,
      price: 0,
      model: 'gemini-2.5-flash' as const,
    },
    pro: {
      tier: 'pro' as const,
      name: 'Pro',
      limit: 10,
      price: 3900,
      model: 'gemini-2.5-pro' as const,
    },
  },

  routes: {
    home: '/',
    signIn: '/sign-in',
    signUp: '/sign-up',
    dashboard: '/dashboard',
    analysisNew: '/analysis/new',
    analysisDetail: (id: string) => `/analysis/${id}`,
    subscription: '/subscription',
  },
} as const;

export const SUBSCRIPTION_STATUS = {
  ACTIVE: 'active',
  CANCELED: 'canceled',
  EXPIRED: 'expired',
} as const;

export type SubscriptionStatus =
  (typeof SUBSCRIPTION_STATUS)[keyof typeof SUBSCRIPTION_STATUS];

export const GENDER_LABELS = {
  male: '남성',
  female: '여성',
} as const;

export const CALENDAR_TYPE_LABELS = {
  solar: '양력',
  lunar: '음력',
} as const;
</file>

<file path="src/constants/landing.ts">
/**
 * 랜딩 페이지 콘텐츠 상수
 */

export const LANDING_CONTENT = {
  hero: {
    title: 'AI가 풀어주는 당신의 사주팔자',
    subtitle: 'Google Gemini AI로 정확하고 체계적인 사주 분석을 경험하세요',
  },
  features: [
    {
      icon: 'Sparkles',
      title: 'AI 기반 정확한 분석',
      description: 'Google Gemini 2.5 Pro 모델을 활용한 체계적이고 정밀한 사주 해석',
    },
    {
      icon: 'DollarSign',
      title: '합리적인 가격',
      description: '월 3,900원으로 10회 고품질 분석 제공, 무료 체험 1회 포함',
    },
    {
      icon: 'Archive',
      title: '영구 보관',
      description: '모든 분석 결과를 대시보드에서 언제든 다시 확인 가능',
    },
  ],
  pricing: [
    {
      tier: 'free' as const,
      name: '무료 체험',
      price: 0,
      features: [
        '1회 무료 분석',
        'Gemini Flash 모델',
        '분석 결과 영구 보관',
      ],
    },
    {
      tier: 'pro' as const,
      name: 'Pro',
      price: 3900,
      features: [
        '월 10회 분석',
        'Gemini Pro 모델',
        '분석 결과 영구 보관',
        '우선 고객 지원',
      ],
    },
  ],
} as const;
</file>

<file path="src/features/analysis/backend/error.ts">
export const AnalysisErrorCode = {
  USAGE_LIMIT_EXCEEDED: 'USAGE_LIMIT_EXCEEDED',
  AI_SERVICE_ERROR: 'AI_SERVICE_ERROR',
  API_QUOTA_EXCEEDED: 'API_QUOTA_EXCEEDED',
  SUBSCRIPTION_EXPIRED: 'SUBSCRIPTION_EXPIRED',
  INVALID_INPUT: 'INVALID_INPUT',
  DATABASE_ERROR: 'DATABASE_ERROR',
  USER_NOT_FOUND: 'USER_NOT_FOUND',
  SUBSCRIPTION_NOT_FOUND: 'SUBSCRIPTION_NOT_FOUND',
  ANALYSIS_NOT_FOUND: 'ANALYSIS_NOT_FOUND',
  ANALYSIS_FORBIDDEN: 'ANALYSIS_FORBIDDEN',
  ANALYSIS_DATA_CORRUPTED: 'ANALYSIS_DATA_CORRUPTED',
} as const;

export type AnalysisErrorCode =
  (typeof AnalysisErrorCode)[keyof typeof AnalysisErrorCode];

export type AnalysisServiceError = AnalysisErrorCode;
</file>

<file path="src/features/analysis/backend/route_dashboard.ts">
import { Hono } from 'hono';
import { zValidator } from '@hono/zod-validator';
import { z } from 'zod';
import { requireAuth } from '@/backend/middleware/auth';
import { respond, success, failure } from '@/backend/http/response';
import { getAnalysisHistory, getAnalysisById } from './service';
import { CommonErrorCode } from '@/backend/errors/codes';
import type { AppEnv } from '@/backend/hono/context';

export const analysisDashboardRouter = new Hono<AppEnv>();

const querySchema = z.object({
  page: z
    .string()
    .transform(Number)
    .pipe(z.number().int().min(1))
    .default('1'),
  limit: z
    .string()
    .transform(Number)
    .pipe(z.number().int().min(1).max(20))
    .default('10'),
});

analysisDashboardRouter.get('/analyses-list', requireAuth(), zValidator('query', querySchema), async (c) => {
  try {
    const userId = c.get('userId');
    const supabase = c.get('supabase');

    if (!userId) {
      return respond(
        c,
        failure(401, CommonErrorCode.UNAUTHORIZED, '로그인이 필요합니다')
      );
    }

    const { page, limit } = c.req.valid('query');

    const history = await getAnalysisHistory(supabase, userId, page, limit);

    return respond(c, success(history));
  } catch (error) {
    const logger = c.get('logger');
    logger.error('Failed to get analysis history', error);

    return respond(
      c,
      failure(500, CommonErrorCode.INTERNAL_ERROR, '분석 이력을 불러올 수 없습니다')
    );
  }
});

analysisDashboardRouter.get('/analyses-detail/:id', requireAuth(), async (c) => {
  try {
    const userId = c.get('userId');
    const supabase = c.get('supabase');

    if (!userId) {
      return respond(
        c,
        failure(401, CommonErrorCode.UNAUTHORIZED, '로그인이 필요합니다')
      );
    }

    const analysisId = c.req.param('id');

    const analysis = await getAnalysisById(supabase, userId, analysisId);

    return respond(c, success(analysis));
  } catch (error) {
    const logger = c.get('logger');
    logger.error('Failed to get analysis', error);

    const message = error instanceof Error ? error.message : 'INTERNAL_ERROR';

    if (message === 'ANALYSIS_NOT_FOUND') {
      return respond(
        c,
        failure(404, CommonErrorCode.NOT_FOUND, '분석 결과를 찾을 수 없습니다')
      );
    }

    if (message === 'ANALYSIS_FORBIDDEN') {
      return respond(
        c,
        failure(403, CommonErrorCode.FORBIDDEN, '접근 권한이 없습니다')
      );
    }

    return respond(
      c,
      failure(500, CommonErrorCode.INTERNAL_ERROR, '분석 결과를 불러올 수 없습니다')
    );
  }
});
</file>

<file path="src/features/analysis/backend/schema.ts">
import { z } from 'zod';

/**
 * 분석 결과 스키마
 */
export const analysisSchema = z.object({
  id: z.string().uuid(),
  userId: z.string().uuid(),
  birthDate: z.string(), // ISO date
  birthTime: z.string().optional(), // HH:mm
  isLunar: z.boolean(),
  gender: z.enum(['male', 'female']),
  result: z.object({
    basic: z.object({
      천간지지: z.string(),
      오행분석: z.string(),
    }),
    personality: z.object({
      특성: z.string(),
      장단점: z.string(),
    }),
    fortune: z.object({
      대운: z.string(),
      세운: z.string(),
      직업운: z.string(),
      재물운: z.string(),
      건강운: z.string(),
      연애운: z.string(),
      대인관계운: z.string(),
    }),
    advice: z.object({
      긍정적방향: z.string(),
      주의점: z.string(),
    }),
  }),
  modelUsed: z.enum(['gemini-2.5-flash', 'gemini-2.5-pro']),
  createdAt: z.string().datetime(),
});

/**
 * 분석 이력 조회 응답 스키마
 */
export const analysisHistoryResponseSchema = z.object({
  data: z.array(analysisSchema),
  total: z.number().int(),
  page: z.number().int(),
  totalPages: z.number().int(),
});

/**
 * 분석 생성 요청 스키마
 */
export const createAnalysisRequestSchema = z.object({
  birthDate: z.string(), // YYYY-MM-DD
  birthTime: z.string().optional(), // HH:mm or undefined
  isLunar: z.boolean(),
  gender: z.enum(['male', 'female']),
});

/**
 * 분석 ID 파라미터 스키마
 */
export const AnalysisIdParamsSchema = z.object({
  id: z.string().uuid(),
});

/**
 * 분석 결과 내부 스키마 (JSONB 필드)
 */
export const analysisResultContentSchema = z.object({
  basic: z.object({
    천간지지: z.string(),
    오행분석: z.string(),
  }),
  personality: z.object({
    특성: z.string(),
    장단점: z.string(),
  }),
  fortune: z.object({
    대운: z.string(),
    세운: z.string(),
    직업운: z.string(),
    재물운: z.string(),
    건강운: z.string(),
    연애운: z.string(),
    대인관계운: z.string(),
  }),
  advice: z.object({
    긍정적방향: z.string(),
    주의점: z.string(),
  }),
});

/**
 * 분석 결과 스키마 (별칭)
 */
export const AnalysisResultSchema = analysisSchema;

/**
 * 분석 상세 응답 스키마
 */
export const analysisDetailResponseSchema = z.object({
  analysis: analysisSchema,
});

export type Analysis = z.infer<typeof analysisSchema>;
export type AnalysisHistoryResponse = z.infer<typeof analysisHistoryResponseSchema>;
export type CreateAnalysisRequest = z.infer<typeof createAnalysisRequestSchema>;
export type AnalysisIdParams = z.infer<typeof AnalysisIdParamsSchema>;
export type AnalysisDetailResponse = z.infer<typeof analysisDetailResponseSchema>;

// Aliases for backward compatibility
export type AnalysisResponse = Analysis;
export type AnalysisResult = Analysis;
</file>

<file path="src/features/analysis/backend/service.ts">
import type { SupabaseClient } from '@supabase/supabase-js';
import type { Analysis, AnalysisHistoryResponse, CreateAnalysisRequest, AnalysisResponse, AnalysisDetailResponse } from './schema';
import { analysisResultContentSchema } from './schema';
import type { AppLogger } from '@/backend/hono/context';
import { checkUsageLimit } from '@/backend/services/usage';
import { callGeminiAnalysis, type GeminiModel } from '@/backend/integrations/gemini/client';
import { AnalysisErrorCode } from './error';
import { failure, success, type HandlerResult } from '@/backend/http/response';
import type { AnalysisServiceError } from './error';
import { AnalysisResultSchema } from './schema';

/**
 * 분석 생성 서비스
 */
export async function createAnalysis(
  supabase: SupabaseClient,
  userId: string,
  input: CreateAnalysisRequest,
  logger: AppLogger,
  geminiApiKey: string
): Promise<HandlerResult<AnalysisResponse, string>> {
  try {
    // 1. 사용자 정보 및 구독 상태 조회
    const { data: user, error: userError } = await supabase
      .from('users')
      .select('id, subscription_tier')
      .eq('id', userId)
      .single();

    if (userError || !user) {
      logger.error('User not found', userError);
      return failure(
        404,
        AnalysisErrorCode.USER_NOT_FOUND,
        '사용자를 찾을 수 없습니다'
      );
    }

    // 2. 사용량 체크
    try {
      const usageInfo = await checkUsageLimit(supabase, userId);

      if (usageInfo.remaining <= 0) {
        logger.warn('Usage limit exceeded', { userId, usageInfo });
        return failure(
          400,
          AnalysisErrorCode.USAGE_LIMIT_EXCEEDED,
          usageInfo.subscriptionTier === 'free'
            ? '무료 체험 1회를 모두 사용하였습니다. Pro 구독을 통해 월 10회 분석을 이용하세요.'
            : '이번 달 분석 횟수를 모두 사용하였습니다.'
        );
      }
    } catch (error) {
      logger.error('Failed to check usage limit', error);
      return failure(
        500,
        AnalysisErrorCode.DATABASE_ERROR,
        '사용량 확인 중 오류가 발생했습니다'
      );
    }

    // 3. 모델 선택
    const subscriptionTier = user.subscription_tier as 'free' | 'pro';
    const model: GeminiModel =
      subscriptionTier === 'pro' ? 'gemini-2.5-pro' : 'gemini-2.5-flash';

    // 4. Gemini AI 분석 호출
    let analysisResult;
    try {
      analysisResult = await callGeminiAnalysis(
        {
          birthDate: new Date(input.birthDate),
          birthTime: input.birthTime || undefined,
          isLunar: input.isLunar,
          gender: input.gender,
        },
        model,
        geminiApiKey
      );
    } catch (error) {
      const errorMessage = (error as Error).message;
      logger.error('Gemini API call failed', { error: errorMessage });

      if (errorMessage.includes('API_QUOTA_EXCEEDED')) {
        return failure(
          503,
          AnalysisErrorCode.API_QUOTA_EXCEEDED,
          'AI 분석 서비스의 할당량이 초과되었습니다. 잠시 후 다시 시도해주세요.'
        );
      }

      return failure(
        503,
        AnalysisErrorCode.AI_SERVICE_ERROR,
        'AI 분석 중 오류가 발생했습니다. 잠시 후 다시 시도해주세요.'
      );
    }

    // 5. 분석 결과 저장
    const { data: analysis, error: insertError } = await supabase
      .from('analyses')
      .insert({
        user_id: userId,
        birth_date: input.birthDate,
        birth_time: input.birthTime || null,
        is_lunar: input.isLunar,
        gender: input.gender,
        result: analysisResult as unknown as Record<string, unknown>,
        model_used: model,
      })
      .select()
      .single();

    if (insertError || !analysis) {
      logger.error('Failed to save analysis', insertError);
      return failure(
        500,
        AnalysisErrorCode.DATABASE_ERROR,
        '분석 결과 저장 중 오류가 발생했습니다'
      );
    }

    logger.info('Analysis created successfully', { analysisId: analysis.id, userId });

    // 6. 응답 반환
    return success({
      id: analysis.id,
      userId: analysis.user_id,
      birthDate: analysis.birth_date,
      birthTime: analysis.birth_time,
      isLunar: analysis.is_lunar,
      gender: analysis.gender,
      result: analysis.result as Record<string, unknown>,
      modelUsed: analysis.model_used,
      createdAt: analysis.created_at,
    });
  } catch (error) {
    logger.error('Unexpected error in createAnalysis', error);
    return failure(
      500,
      'INTERNAL_ERROR',
      '분석 처리 중 예상치 못한 오류가 발생했습니다'
    );
  }
}

/**
 * 분석 이력 조회
 */
export async function getAnalysisHistory(
  supabase: SupabaseClient,
  userId: string,
  page: number,
  limit: number
): Promise<AnalysisHistoryResponse> {
  const offset = (page - 1) * limit;

  const { count, error: countError } = await supabase
    .from('analyses')
    .select('*', { count: 'exact', head: true })
    .eq('user_id', userId);

  if (countError) {
    throw new Error('FAILED_TO_COUNT_ANALYSES');
  }

  const total = count ?? 0;
  const totalPages = Math.ceil(total / limit);

  const { data, error } = await supabase
    .from('analyses')
    .select('*')
    .eq('user_id', userId)
    .order('created_at', { ascending: false })
    .range(offset, offset + limit - 1);

  if (error) {
    throw new Error('FAILED_TO_FETCH_ANALYSES');
  }

  return {
    data: data.map((item) => ({
      id: item.id,
      userId: item.user_id,
      birthDate: item.birth_date,
      birthTime: item.birth_time,
      isLunar: item.is_lunar,
      gender: item.gender,
      result: item.result,
      modelUsed: item.model_used,
      createdAt: item.created_at,
    })),
    total,
    page,
    totalPages,
  };
}

/**
 * 특정 분석 상세 조회
 */
export async function getAnalysisById(
  supabase: SupabaseClient,
  userId: string,
  analysisId: string
): Promise<Analysis> {
  const { data, error } = await supabase
    .from('analyses')
    .select('*')
    .eq('id', analysisId)
    .single();

  if (error || !data) {
    throw new Error('ANALYSIS_NOT_FOUND');
  }

  if (data.user_id !== userId) {
    throw new Error('ANALYSIS_FORBIDDEN');
  }

  return {
    id: data.id,
    userId: data.user_id,
    birthDate: data.birth_date,
    birthTime: data.birth_time,
    isLunar: data.is_lunar,
    gender: data.gender,
    result: data.result,
    modelUsed: data.model_used,
    createdAt: data.created_at,
  };
}

/**
 * 분석 상세 조회 (상세보기 페이지용 - HandlerResult 패턴)
 */
export async function getAnalysisDetail(
  supabase: SupabaseClient,
  analysisId: string,
  userId: string
): Promise<HandlerResult<AnalysisDetailResponse, AnalysisServiceError>> {
  // 1. 분석 조회
  const { data, error } = await supabase
    .from('analyses')
    .select('*')
    .eq('id', analysisId)
    .single();

  // 2. 데이터베이스 오류 처리
  if (error) {
    return failure(
      404,
      AnalysisErrorCode.ANALYSIS_NOT_FOUND,
      '분석을 찾을 수 없습니다'
    );
  }

  // 3. 존재하지 않는 분석
  if (!data) {
    return failure(
      404,
      AnalysisErrorCode.ANALYSIS_NOT_FOUND,
      '분석을 찾을 수 없습니다'
    );
  }

  // 4. 권한 확인 (본인 분석만 조회 가능)
  if (data.user_id !== userId) {
    return failure(
      403,
      AnalysisErrorCode.ANALYSIS_FORBIDDEN,
      '본인의 분석 결과만 조회할 수 있습니다'
    );
  }

  // 5. JSONB 파싱 검증
  const resultValidation = analysisResultContentSchema.safeParse(data.result);
  if (!resultValidation.success) {
    return failure(
      500,
      AnalysisErrorCode.ANALYSIS_DATA_CORRUPTED,
      '분석 결과를 불러오는 중 오류가 발생했습니다',
      resultValidation.error.format()
    );
  }

  // 6. DTO 변환 및 반환
  const response: AnalysisDetailResponse = {
    analysis: {
      id: data.id,
      userId: data.user_id,
      birthDate: data.birth_date,
      birthTime: data.birth_time,
      isLunar: data.is_lunar,
      gender: data.gender,
      modelUsed: data.model_used,
      result: resultValidation.data,
      createdAt: data.created_at,
    },
  };

  return success(response);
}
</file>

<file path="src/features/analysis/backend/service.ts.backup">
import type { SupabaseClient } from '@supabase/supabase-js';
import type { Analysis, AnalysisHistoryResponse } from './schema';
import { failure, success, type HandlerResult } from '@/backend/http/response';
import { AnalysisErrorCode } from './error';
import type { AnalysisServiceError } from './error';
import { AnalysisResultSchema, type AnalysisDetailResponse } from './schema';

/**
 * 분석 이력 조회
 */
export async function getAnalysisHistory(
  supabase: SupabaseClient,
  userId: string,
  page: number,
  limit: number
): Promise<AnalysisHistoryResponse> {
  const offset = (page - 1) * limit;

  const { count, error: countError } = await supabase
    .from('analyses')
    .select('*', { count: 'exact', head: true })
    .eq('user_id', userId);

  if (countError) {
    throw new Error('FAILED_TO_COUNT_ANALYSES');
  }

  const total = count ?? 0;
  const totalPages = Math.ceil(total / limit);

  const { data, error } = await supabase
    .from('analyses')
    .select('*')
    .eq('user_id', userId)
    .order('created_at', { ascending: false })
    .range(offset, offset + limit - 1);

  if (error) {
    throw new Error('FAILED_TO_FETCH_ANALYSES');
  }

  return {
    data: data.map((item) => ({
      id: item.id,
      userId: item.user_id,
      birthDate: item.birth_date,
      birthTime: item.birth_time,
      isLunar: item.is_lunar,
      gender: item.gender,
      result: item.result,
      modelUsed: item.model_used,
      createdAt: item.created_at,
    })),
    total,
    page,
    totalPages,
  };
}

/**
 * 특정 분석 상세 조회
 */
export async function getAnalysisById(
  supabase: SupabaseClient,
  userId: string,
  analysisId: string
): Promise<Analysis> {
  const { data, error } = await supabase
    .from('analyses')
    .select('*')
    .eq('id', analysisId)
    .single();

  if (error || !data) {
    throw new Error('ANALYSIS_NOT_FOUND');
  }

  if (data.user_id !== userId) {
    throw new Error('ANALYSIS_FORBIDDEN');
  }

  return {
    id: data.id,
    userId: data.user_id,
    birthDate: data.birth_date,
    birthTime: data.birth_time,
    isLunar: data.is_lunar,
    gender: data.gender,
    result: data.result,
    modelUsed: data.model_used,
    createdAt: data.created_at,
  };
}

/**
 * 분석 상세 조회 (상세보기 페이지용 - HandlerResult 패턴)
 */
export async function getAnalysisDetail(
  supabase: SupabaseClient,
  analysisId: string,
  userId: string
): Promise<HandlerResult<AnalysisDetailResponse, AnalysisServiceError>> {
  // 1. 분석 조회
  const { data, error } = await supabase
    .from('analyses')
    .select('*')
    .eq('id', analysisId)
    .single();

  // 2. 데이터베이스 오류 처리
  if (error) {
    return failure(
      404,
      AnalysisErrorCode.ANALYSIS_NOT_FOUND,
      '분석을 찾을 수 없습니다'
    );
  }

  // 3. 존재하지 않는 분석
  if (!data) {
    return failure(
      404,
      AnalysisErrorCode.ANALYSIS_NOT_FOUND,
      '분석을 찾을 수 없습니다'
    );
  }

  // 4. 권한 확인 (본인 분석만 조회 가능)
  if (data.user_id !== userId) {
    return failure(
      403,
      AnalysisErrorCode.ANALYSIS_FORBIDDEN,
      '본인의 분석 결과만 조회할 수 있습니다'
    );
  }

  // 5. JSONB 파싱 검증
  const resultValidation = AnalysisResultSchema.safeParse(data.result);
  if (!resultValidation.success) {
    return failure(
      500,
      AnalysisErrorCode.ANALYSIS_DATA_CORRUPTED,
      '분석 결과를 불러오는 중 오류가 발생했습니다',
      resultValidation.error.format()
    );
  }

  // 6. DTO 변환 및 반환
  const response: AnalysisDetailResponse = {
    id: data.id,
    userId: data.user_id,
    birthDate: data.birth_date,
    birthTime: data.birth_time,
    isLunar: data.is_lunar,
    gender: data.gender,
    modelUsed: data.model_used,
    result: resultValidation.data,
    createdAt: data.created_at,
  };

  return success(response);
}
</file>

<file path="src/features/analysis/components/action-buttons.tsx">
'use client';

import { Button } from '@/components/ui/button';
import { ArrowLeft } from 'lucide-react';

interface ActionButtonsProps {
  onBackToDashboard: () => void;
}

export function ActionButtons({ onBackToDashboard }: ActionButtonsProps) {
  return (
    <div className="flex justify-center mt-8">
      <Button onClick={onBackToDashboard} variant="outline" size="lg">
        <ArrowLeft className="mr-2 h-4 w-4" />
        대시보드로 돌아가기
      </Button>
    </div>
  );
}
</file>

<file path="src/features/analysis/components/analysis-form.tsx">
'use client';

import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { useRouter } from 'next/navigation';
import { useAnalysisNew } from '../context/analysis-new-context';
import { analysisRequestSchema, type AnalysisRequestInput } from '@/lib/validation/schemas';
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from '@/components/ui/form';
import { Input } from '@/components/ui/input';
import { Button } from '@/components/ui/button';
import { RadioGroup, RadioGroupItem } from '@/components/ui/radio-group';
import { Checkbox } from '@/components/ui/checkbox';
import { APP_CONFIG, GENDER_LABELS } from '@/constants/app';
import { toast } from '@/hooks/use-toast';

/**
 * 분석 폼 컴포넌트
 */
export function AnalysisForm() {
  const { canSubmit, usageExceeded, submitAnalysis, state } = useAnalysisNew();
  const router = useRouter();

  const form = useForm<AnalysisRequestInput>({
    resolver: zodResolver(analysisRequestSchema),
    defaultValues: {
      birthDate: undefined,
      birthTime: undefined,
      birthTimeUnknown: false,
      isLunar: false,
      gender: undefined,
    },
  });

  const birthTimeUnknown = form.watch('birthTimeUnknown');

  const onSubmit = async (data: AnalysisRequestInput) => {
    try {
      const requestData = {
        birthDate: data.birthDate!.toISOString().split('T')[0],
        birthTime: data.birthTimeUnknown ? undefined : data.birthTime,
        isLunar: data.isLunar,
        gender: data.gender!,
      };

      const analysisId = await submitAnalysis(requestData);

      toast({
        title: '분석 완료',
        description: '사주 분석이 완료되었습니다',
      });

      router.push(APP_CONFIG.routes.analysisDetail(analysisId));
    } catch (error) {
      // 에러는 Context에서 처리됨
    }
  };

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
        {/* 생년월일 */}
        <FormField
          control={form.control}
          name="birthDate"
          render={({ field }) => (
            <FormItem>
              <FormLabel>생년월일 *</FormLabel>
              <FormControl>
                <Input
                  type="date"
                  {...field}
                  value={field.value ? field.value.toISOString().split('T')[0] : ''}
                  onChange={(e) => field.onChange(e.target.value ? new Date(e.target.value) : undefined)}
                  max={new Date().toISOString().split('T')[0]}
                  min="1900-01-01"
                  disabled={usageExceeded}
                />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        {/* 출생 시간 */}
        <FormField
          control={form.control}
          name="birthTime"
          render={({ field }) => (
            <FormItem>
              <FormLabel>출생 시간</FormLabel>
              <FormControl>
                <Input
                  type="time"
                  {...field}
                  value={field.value || ''}
                  disabled={birthTimeUnknown || usageExceeded}
                  placeholder="HH:MM"
                />
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        {/* 모름 체크박스 */}
        <FormField
          control={form.control}
          name="birthTimeUnknown"
          render={({ field }) => (
            <FormItem className="flex items-center space-x-2">
              <FormControl>
                <Checkbox
                  checked={field.value}
                  onCheckedChange={(checked) => {
                    field.onChange(checked);
                    if (checked) {
                      form.setValue('birthTime', undefined);
                    }
                  }}
                  disabled={usageExceeded}
                />
              </FormControl>
              <FormLabel className="!mt-0">출생 시간을 모릅니다</FormLabel>
            </FormItem>
          )}
        />

        {/* 양력/음력 */}
        <FormField
          control={form.control}
          name="isLunar"
          render={({ field }) => (
            <FormItem>
              <FormLabel>양력/음력 *</FormLabel>
              <FormControl>
                <RadioGroup
                  onValueChange={(value) => field.onChange(value === 'lunar')}
                  value={field.value ? 'lunar' : 'solar'}
                  disabled={usageExceeded}
                  className="flex gap-4"
                >
                  <div className="flex items-center space-x-2">
                    <RadioGroupItem value="solar" id="solar" />
                    <label htmlFor="solar">양력</label>
                  </div>
                  <div className="flex items-center space-x-2">
                    <RadioGroupItem value="lunar" id="lunar" />
                    <label htmlFor="lunar">음력</label>
                  </div>
                </RadioGroup>
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        {/* 성별 */}
        <FormField
          control={form.control}
          name="gender"
          render={({ field }) => (
            <FormItem>
              <FormLabel>성별 *</FormLabel>
              <FormControl>
                <RadioGroup
                  onValueChange={field.onChange}
                  value={field.value}
                  disabled={usageExceeded}
                  className="flex gap-4"
                >
                  <div className="flex items-center space-x-2">
                    <RadioGroupItem value="male" id="male" />
                    <label htmlFor="male">{GENDER_LABELS.male}</label>
                  </div>
                  <div className="flex items-center space-x-2">
                    <RadioGroupItem value="female" id="female" />
                    <label htmlFor="female">{GENDER_LABELS.female}</label>
                  </div>
                </RadioGroup>
              </FormControl>
              <FormMessage />
            </FormItem>
          )}
        />

        {/* 제출 버튼 */}
        <Button
          type="submit"
          className="w-full"
          disabled={!canSubmit || usageExceeded || state.isSubmitting}
          size="lg"
        >
          {state.isSubmitting ? '분석 중...' : usageExceeded ? '사용량 초과' : '분석하기'}
        </Button>

        {/* Pro 업그레이드 버튼 (무료 유저 사용량 초과 시) */}
        {usageExceeded && state.usageInfo?.subscriptionTier === 'free' && (
          <Button
            variant="outline"
            className="w-full"
            onClick={() => router.push(APP_CONFIG.routes.subscription)}
          >
            Pro로 업그레이드
          </Button>
        )}
      </form>
    </Form>
  );
}
</file>

<file path="src/features/analysis/components/analysis-header.tsx">
'use client';

import { formatDate } from '@/lib/utils/date';
import { Badge } from '@/components/ui/badge';
import { GENDER_LABELS } from '@/constants/app';
import type { AnalysisDetail } from '../lib/dto';

interface AnalysisHeaderProps {
  analysis: AnalysisDetail;
}

export function AnalysisHeader({ analysis }: AnalysisHeaderProps) {
  const modelBadge =
    analysis.modelUsed === 'gemini-2.5-pro' ? (
      <Badge variant="default">Pro 모델</Badge>
    ) : (
      <Badge variant="secondary">Flash 모델</Badge>
    );

  const calendarType = analysis.isLunar ? '음력' : '양력';
  const genderLabel = GENDER_LABELS[analysis.gender];
  const birthTimeDisplay = analysis.birthTime ?? '모름';

  return (
    <div className="bg-card rounded-lg border p-6 space-y-4">
      <div className="flex items-center justify-between">
        <h1 className="text-2xl font-bold">사주 분석 결과</h1>
        {modelBadge}
      </div>

      <div className="grid grid-cols-2 gap-4 text-sm">
        <div>
          <span className="text-muted-foreground">분석 날짜</span>
          <p className="font-medium">
            {formatDate(analysis.createdAt, 'yyyy년 MM월 dd일 HH:mm')}
          </p>
        </div>

        <div>
          <span className="text-muted-foreground">생년월일</span>
          <p className="font-medium">
            {formatDate(analysis.birthDate, 'yyyy년 MM월 dd일')} ({calendarType})
          </p>
        </div>

        <div>
          <span className="text-muted-foreground">출생 시간</span>
          <p className="font-medium">{birthTimeDisplay}</p>
        </div>

        <div>
          <span className="text-muted-foreground">성별</span>
          <p className="font-medium">{genderLabel}</p>
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/features/analysis/components/analysis-new-page.tsx">
'use client';

import { useEffect } from 'react';
import { useAnalysisNew } from '../context/analysis-new-context';
import { UsageDisplay } from './usage-display';
import { AnalysisForm } from './analysis-form';
import { ErrorAlert } from './error-alert';
import { Card } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { useRouter } from 'next/navigation';
import { ArrowLeft } from 'lucide-react';
import { APP_CONFIG } from '@/constants/app';

/**
 * 새 분석하기 메인 페이지 컴포넌트
 */
export function AnalysisNewPage() {
  const { fetchUsage, state } = useAnalysisNew();
  const router = useRouter();

  useEffect(() => {
    fetchUsage();
  }, []);

  return (
    <div className="container max-w-2xl mx-auto py-8 px-4">
      {/* 상단 헤더 */}
      <div className="mb-6">
        <Button
          variant="ghost"
          onClick={() => router.push(APP_CONFIG.routes.dashboard)}
          className="mb-4"
        >
          <ArrowLeft className="w-4 h-4 mr-2" />
          대시보드로
        </Button>
        <h1 className="text-3xl font-bold">새 분석하기</h1>
        <p className="text-muted-foreground mt-2">
          AI가 당신의 사주를 분석합니다
        </p>
      </div>

      {/* 사용량 표시 */}
      <UsageDisplay />

      {/* 에러 표시 */}
      {state.usageError && (
        <ErrorAlert
          message="사용량 정보를 불러오지 못했습니다"
          onRetry={fetchUsage}
        />
      )}

      {state.submitError && (
        <ErrorAlert message={state.submitError} />
      )}

      {/* 분석 폼 */}
      <Card className="p-6 mt-6">
        <AnalysisForm />
      </Card>

      {/* 로딩 오버레이 */}
      {state.isSubmitting && (
        <div className="fixed inset-0 bg-background/80 z-50 flex items-center justify-center">
          <div className="flex flex-col items-center gap-4">
            <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-primary" />
            <p className="text-sm text-muted-foreground">AI가 사주를 분석하고 있습니다...</p>
          </div>
        </div>
      )}
    </div>
  );
}
</file>

<file path="src/features/analysis/components/error-alert.tsx">
'use client';

import { Alert, AlertDescription, AlertTitle } from '@/components/ui/alert';
import { Button } from '@/components/ui/button';
import { AlertCircle } from 'lucide-react';

interface ErrorAlertProps {
  message: string;
  onRetry?: () => void;
}

/**
 * 에러 알림 컴포넌트
 */
export function ErrorAlert({ message, onRetry }: ErrorAlertProps) {
  return (
    <Alert variant="destructive" className="mb-4">
      <AlertCircle className="h-4 w-4" />
      <AlertTitle>오류</AlertTitle>
      <AlertDescription className="flex items-center justify-between">
        <span>{message}</span>
        {onRetry && (
          <Button variant="outline" size="sm" onClick={onRetry}>
            재시도
          </Button>
        )}
      </AlertDescription>
    </Alert>
  );
}
</file>

<file path="src/features/analysis/components/error-page.tsx">
'use client';

import { Button } from '@/components/ui/button';
import { AlertCircle } from 'lucide-react';

interface ErrorPageProps {
  title: string;
  message: string;
  action: {
    label: string;
    onClick: () => void;
  };
}

export function ErrorPage({ title, message, action }: ErrorPageProps) {
  return (
    <div className="container max-w-md mx-auto py-16 text-center">
      <AlertCircle className="h-16 w-16 text-destructive mx-auto mb-4" />
      <h1 className="text-2xl font-bold mb-2">{title}</h1>
      <p className="text-muted-foreground mb-6">{message}</p>
      <Button onClick={action.onClick}>{action.label}</Button>
    </div>
  );
}
</file>

<file path="src/features/analysis/components/result-section.tsx">
'use client';

import {
  Card,
  CardHeader,
  CardTitle,
  CardContent,
} from '@/components/ui/card';

interface ResultSectionProps {
  title: string;
  data: Record<string, string>;
}

export function ResultSection({ title, data }: ResultSectionProps) {
  return (
    <Card>
      <CardHeader>
        <CardTitle>{title}</CardTitle>
      </CardHeader>
      <CardContent className="space-y-4">
        {Object.entries(data).map(([key, value]) => (
          <div key={key}>
            <h4 className="font-semibold text-sm text-muted-foreground mb-1">
              {key}
            </h4>
            <p className="text-sm whitespace-pre-wrap">{value}</p>
          </div>
        ))}
      </CardContent>
    </Card>
  );
}
</file>

<file path="src/features/analysis/components/usage-display.tsx">
'use client';

import { useAnalysisNew } from '../context/analysis-new-context';
import { Card } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { Skeleton } from '@/components/ui/skeleton';
import { BarChart3, Calendar } from 'lucide-react';
import { formatDate } from '@/lib/utils/date';

/**
 * 사용량 표시 컴포넌트
 */
export function UsageDisplay() {
  const { state, usageExceeded } = useAnalysisNew();

  if (state.isLoadingUsage) {
    return (
      <Card className="p-4">
        <Skeleton className="h-6 w-48 mb-2" />
        <Skeleton className="h-4 w-32" />
      </Card>
    );
  }

  if (!state.usageInfo) {
    return null;
  }

  const { used, limit, remaining, subscriptionTier, nextResetDate } = state.usageInfo;

  return (
    <Card className="p-4 border-2">
      <div className="flex items-center justify-between">
        <div className="flex items-center gap-3">
          <BarChart3 className="w-5 h-5 text-primary" />
          <div>
            <div className="flex items-center gap-2">
              <span className="font-semibold text-lg">
                남은 분석 횟수: {remaining}/{limit}회
              </span>
              <Badge variant={subscriptionTier === 'pro' ? 'default' : 'secondary'}>
                {subscriptionTier === 'pro' ? 'Pro' : '무료'}
              </Badge>
            </div>
            {nextResetDate && subscriptionTier === 'pro' && (
              <div className="flex items-center gap-1 text-sm text-muted-foreground mt-1">
                <Calendar className="w-3 h-3" />
                <span>다음 초기화: {formatDate(nextResetDate, 'yyyy-MM-dd')}</span>
              </div>
            )}
            {usageExceeded && (
              <p className="text-sm text-destructive mt-1">
                {subscriptionTier === 'free'
                  ? '무료 체험 1회를 모두 사용하였습니다'
                  : '이번 달 분석 횟수를 모두 사용하였습니다'}
              </p>
            )}
          </div>
        </div>
      </div>
    </Card>
  );
}
</file>

<file path="src/features/analysis/lib/dto.ts">
export type { Analysis, AnalysisHistoryResponse, AnalysisDetailResponse } from '../backend/schema';

// backend/schema에서 정의한 타입을 프론트엔드에서 재사용
export type { Analysis as AnalysisDetail, AnalysisResult } from '../backend/schema';
</file>

<file path="src/features/auth/backend/route.ts">
import { Hono } from 'hono';
import { requireAuth } from '@/backend/middleware/auth';
import { respond, success, failure } from '@/backend/http/response';
import { getCurrentUser } from './service';
import { CommonErrorCode } from '@/backend/errors/codes';
import type { AppEnv } from '@/backend/hono/context';

export const authRouter = new Hono<AppEnv>();

/**
 * GET /api/me
 *
 * 현재 로그인한 사용자 정보 조회
 */
authRouter.get('/me', requireAuth(), async (c) => {
  try {
    const userId = c.get('userId');
    const supabase = c.get('supabase');

    if (!userId) {
      return respond(
        c,
        failure(401, CommonErrorCode.UNAUTHORIZED, '로그인이 필요합니다')
      );
    }

    const user = await getCurrentUser(supabase, userId);

    return respond(c, success(user));
  } catch (error) {
    const logger = c.get('logger');
    logger.error('Failed to get current user', error);

    const message = error instanceof Error ? error.message : 'INTERNAL_ERROR';

    if (message === 'USER_NOT_FOUND') {
      return respond(
        c,
        failure(404, CommonErrorCode.NOT_FOUND, '사용자 정보를 찾을 수 없습니다')
      );
    }

    return respond(
      c,
      failure(500, CommonErrorCode.INTERNAL_ERROR, '사용자 정보를 불러올 수 없습니다')
    );
  }
});
</file>

<file path="src/features/auth/backend/schema.ts">
import { z } from 'zod';

/**
 * 구독 정보 스키마
 */
const subscriptionInfoSchema = z.object({
  status: z.enum(['active', 'canceled', 'expired']),
  nextBillingDate: z.string().datetime().optional(),
});

/**
 * 현재 사용자 조회 응답 스키마
 */
export const currentUserResponseSchema = z.object({
  id: z.string().uuid(),
  clerkUserId: z.string(),
  email: z.string().email(),
  subscriptionTier: z.enum(['free', 'pro']),
  subscription: subscriptionInfoSchema.optional(),
});

export type CurrentUserResponse = z.infer<typeof currentUserResponseSchema>;
</file>

<file path="src/features/auth/backend/service.ts">
import type { SupabaseClient } from '@supabase/supabase-js';
import type { CurrentUserResponse } from './schema';

/**
 * 현재 사용자 정보 조회
 *
 * @param supabase Supabase 클라이언트
 * @param userId 사용자 UUID
 * @returns 사용자 정보
 * @throws {Error} 사용자를 찾을 수 없는 경우
 */
export async function getCurrentUser(
  supabase: SupabaseClient,
  userId: string
): Promise<CurrentUserResponse> {
  // 1. users 테이블에서 사용자 정보 조회
  const { data: user, error: userError } = await supabase
    .from('users')
    .select('id, clerk_user_id, email, subscription_tier')
    .eq('id', userId)
    .single();

  if (userError || !user) {
    throw new Error('USER_NOT_FOUND');
  }

  // 2. Pro 유저인 경우 구독 정보 조회
  let subscription = undefined;
  if (user.subscription_tier === 'pro') {
    const { data: sub } = await supabase
      .from('subscriptions')
      .select('status, next_billing_date')
      .eq('user_id', userId)
      .in('status', ['active', 'canceled'])
      .single();

    subscription = sub
      ? {
          status: sub.status as 'active' | 'canceled' | 'expired',
          nextBillingDate: sub.next_billing_date,
        }
      : undefined;
  }

  return {
    id: user.id,
    clerkUserId: user.clerk_user_id,
    email: user.email,
    subscriptionTier: user.subscription_tier as 'free' | 'pro',
    subscription,
  };
}
</file>

<file path="src/features/auth/context/current-user-context.tsx">
"use client";

import {
  createContext,
  useCallback,
  useContext,
  useMemo,
  useState,
  type ReactNode,
} from "react";
import { useQueryClient } from "@tanstack/react-query";
import { match, P } from "ts-pattern";
import { getSupabaseBrowserClient } from "@/lib/supabase/browser-client";
import type {
  CurrentUserContextValue,
  CurrentUserSnapshot,
} from "../types";

const CurrentUserContext = createContext<CurrentUserContextValue | null>(null);

type CurrentUserProviderProps = {
  children: ReactNode;
  initialState: CurrentUserSnapshot;
};

export const CurrentUserProvider = ({
  children,
  initialState,
}: CurrentUserProviderProps) => {
  const queryClient = useQueryClient();
  const [snapshot, setSnapshot] = useState<CurrentUserSnapshot>(initialState);

  const refresh = useCallback(async () => {
    setSnapshot((prev) => ({ status: "loading", user: prev.user }));
    const supabase = getSupabaseBrowserClient();

    try {
      const result = await supabase.auth.getUser();

      const nextSnapshot = match(result)
        .with({ data: { user: P.nonNullable } }, ({ data }) => ({
          status: "authenticated" as const,
          user: {
            id: data.user.id,
            email: data.user.email,
            appMetadata: data.user.app_metadata ?? {},
            userMetadata: data.user.user_metadata ?? {},
          },
        }))
        .otherwise(() => ({ status: "unauthenticated" as const, user: null }));

      setSnapshot(nextSnapshot);
      queryClient.setQueryData(["currentUser"], nextSnapshot);
    } catch (error) {
      const fallbackSnapshot: CurrentUserSnapshot = {
        status: "unauthenticated",
        user: null,
      };
      setSnapshot(fallbackSnapshot);
      queryClient.setQueryData(["currentUser"], fallbackSnapshot);
    }
  }, [queryClient]);

  const value = useMemo<CurrentUserContextValue>(() => {
    return {
      ...snapshot,
      refresh,
      isAuthenticated: snapshot.status === "authenticated",
      isLoading: snapshot.status === "loading",
    };
  }, [refresh, snapshot]);

  return (
    <CurrentUserContext.Provider value={value}>
      {children}
    </CurrentUserContext.Provider>
  );
};

export const useCurrentUserContext = () => {
  const value = useContext(CurrentUserContext);

  if (!value) {
    throw new Error("CurrentUserProvider가 트리 상단에 필요합니다.");
  }

  return value;
};
</file>

<file path="src/features/auth/hooks/useCurrentUser.ts">
"use client";

import { useMemo } from "react";
import { useCurrentUserContext } from "../context/current-user-context";

export const useCurrentUser = () => {
  const context = useCurrentUserContext();

  return useMemo(
    () => ({
      user: context.user,
      status: context.status,
      isAuthenticated: context.isAuthenticated,
      isLoading: context.isLoading,
      refresh: context.refresh,
    }),
    [context]
  );
};
</file>

<file path="src/features/auth/lib/dto.ts">
export type { CurrentUserResponse } from '../backend/schema';
</file>

<file path="src/features/auth/server/load-current-user.ts">
import "server-only";

import type { User } from "@supabase/supabase-js";
import { createSupabaseServerClient } from "@/lib/supabase/server-client";
import type { CurrentUserSnapshot } from "../types";

const mapUser = (user: User) => ({
  id: user.id,
  email: user.email,
  appMetadata: user.app_metadata ?? {},
  userMetadata: user.user_metadata ?? {},
});

export const loadCurrentUser = async (): Promise<CurrentUserSnapshot> => {
  const supabase = await createSupabaseServerClient();
  const result = await supabase.auth.getUser();
  const user = result.data.user;

  if (user) {
    return {
      status: "authenticated",
      user: mapUser(user),
    };
  }

  return { status: "unauthenticated", user: null };
};
</file>

<file path="src/features/auth/types.ts">
export type CurrentUser = {
  id: string;
  email: string | null;
  appMetadata: Record<string, unknown>;
  userMetadata: Record<string, unknown>;
};

export type CurrentUserSnapshot =
  | { status: "authenticated"; user: CurrentUser }
  | { status: "unauthenticated"; user: null }
  | { status: "loading"; user: CurrentUser | null };

export type CurrentUserContextValue = CurrentUserSnapshot & {
  refresh: () => Promise<void>;
  isAuthenticated: boolean;
  isLoading: boolean;
};
</file>

<file path="src/features/dashboard/backend/route.ts">
import { Hono } from 'hono';
import { requireAuth } from '@/backend/middleware/auth';
import { respond, success, failure } from '@/backend/http/response';
import { checkUsageLimit } from '@/backend/services/usage';
import { CommonErrorCode } from '@/backend/errors/codes';
import type { AppEnv } from '@/backend/hono/context';

export const dashboardRouter = new Hono<AppEnv>();

/**
 * GET /api/me/usage
 *
 * 현재 사용자의 사용량 정보 조회
 */
dashboardRouter.get('/me/usage', requireAuth(), async (c) => {
  try {
    const userId = c.get('userId');
    const supabase = c.get('supabase');

    if (!userId) {
      return respond(
        c,
        failure(401, CommonErrorCode.UNAUTHORIZED, '로그인이 필요합니다')
      );
    }

    const usageInfo = await checkUsageLimit(supabase, userId);

    // Date를 ISO string으로 변환
    const response = {
      ...usageInfo,
      nextResetDate: usageInfo.nextResetDate?.toISOString(),
    };

    return respond(c, success(response));
  } catch (error) {
    const logger = c.get('logger');
    logger.error('Failed to get usage info', error);

    return respond(
      c,
      failure(500, CommonErrorCode.INTERNAL_ERROR, '사용량 정보를 불러올 수 없습니다')
    );
  }
});
</file>

<file path="src/features/dashboard/backend/schema.ts">
import { z } from 'zod';

/**
 * 사용량 정보 응답 스키마
 */
export const usageInfoResponseSchema = z.object({
  used: z.number().int().min(0),
  limit: z.number().int().min(1),
  remaining: z.number().int().min(0),
  nextResetDate: z.string().datetime().optional(),
});

export type UsageInfoResponse = z.infer<typeof usageInfoResponseSchema>;
</file>

<file path="src/features/dashboard/components/analysis-card.tsx">
'use client';

import { useRouter } from 'next/navigation';
import { Card, CardContent, CardFooter, CardHeader } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { formatDate } from '@/lib/utils/date';
import { APP_CONFIG } from '@/constants/app';
import type { Analysis } from '@/features/analysis/lib/dto';

interface AnalysisCardProps {
  analysis: Analysis;
}

export function AnalysisCard({ analysis }: AnalysisCardProps) {
  const router = useRouter();

  const maskedBirthDate = analysis.birthDate.replace(/-\d{2}-\d{2}$/, '-**-**');
  const preview = analysis.result.personality.특성.slice(0, 100) + '...';

  return (
    <Card className="hover:shadow-lg transition-shadow">
      <CardHeader>
        <div className="flex items-start justify-between">
          <div>
            <p className="text-sm text-muted-foreground">
              {formatDate(new Date(analysis.createdAt), 'yyyy년 MM월 dd일 HH:mm')}
            </p>
            <p className="font-medium">{maskedBirthDate}</p>
          </div>
          <Badge variant={analysis.modelUsed === 'gemini-2.5-pro' ? 'default' : 'secondary'}>
            {analysis.modelUsed === 'gemini-2.5-pro' ? 'Pro' : 'Flash'}
          </Badge>
        </div>
      </CardHeader>
      <CardContent>
        <p className="text-sm text-muted-foreground line-clamp-3">{preview}</p>
      </CardContent>
      <CardFooter>
        <Button
          variant="outline"
          className="w-full"
          onClick={() => router.push(APP_CONFIG.routes.analysisDetail(analysis.id))}
        >
          자세히 보기
        </Button>
      </CardFooter>
    </Card>
  );
}
</file>

<file path="src/features/dashboard/components/dashboard-header.tsx">
'use client';

import { Card, CardContent } from '@/components/ui/card';
import { SubscriptionBadge } from './subscription-badge';
import { UsageIndicator } from './usage-indicator';
import type { CurrentUserResponse } from '@/features/auth/lib/dto';
import type { UsageInfoResponse } from '../lib/dto';

interface DashboardHeaderProps {
  user: CurrentUserResponse;
  usage: UsageInfoResponse;
}

export function DashboardHeader({ user, usage }: DashboardHeaderProps) {
  return (
    <Card>
      <CardContent className="pt-6">
        <div className="space-y-4">
          <div>
            <h1 className="text-2xl font-bold">안녕하세요, {user.email}님!</h1>
            <p className="text-muted-foreground">대시보드에 오신 것을 환영합니다.</p>
          </div>

          <div className="flex flex-col sm:flex-row gap-4">
            <SubscriptionBadge
              tier={user.subscriptionTier}
              subscription={user.subscription}
            />
            <UsageIndicator usage={usage} />
          </div>
        </div>
      </CardContent>
    </Card>
  );
}
</file>

<file path="src/features/dashboard/components/subscription-badge.tsx">
'use client';

import { Badge } from '@/components/ui/badge';
import { match } from 'ts-pattern';

interface SubscriptionBadgeProps {
  tier: 'free' | 'pro';
  subscription?: {
    status?: 'active' | 'canceled' | 'expired';
    nextBillingDate?: string;
  };
}

export function SubscriptionBadge({ tier, subscription }: SubscriptionBadgeProps) {
  const label = match({ tier, status: subscription?.status })
    .with({ tier: 'free' }, () => '무료 체험')
    .with({ tier: 'pro', status: 'active' }, () => 'Pro 구독 중')
    .with({ tier: 'pro', status: 'canceled' }, () => 'Pro (취소 예정)')
    .with({ tier: 'pro', status: 'expired' }, () => '구독 만료')
    .otherwise(() => '무료 체험');

  const variant = match({ tier, status: subscription?.status })
    .with({ tier: 'pro', status: 'active' }, () => 'default' as const)
    .with({ tier: 'pro', status: 'canceled' }, () => 'secondary' as const)
    .otherwise(() => 'outline' as const);

  return <Badge variant={variant}>{label}</Badge>;
}
</file>

<file path="src/features/dashboard/components/usage-indicator.tsx">
'use client';

import { formatRelativeDate } from '@/lib/utils/date';
import type { UsageInfoResponse } from '../lib/dto';

interface UsageIndicatorProps {
  usage: UsageInfoResponse;
}

export function UsageIndicator({ usage }: UsageIndicatorProps) {
  const { used, limit, remaining, nextResetDate } = usage;

  return (
    <div className="space-y-1">
      <p className="text-sm font-medium">
        남은 분석: <span className="text-lg font-bold">{remaining}/{limit}회</span>
      </p>
      {nextResetDate && (
        <p className="text-xs text-muted-foreground">
          다음 초기화: {formatRelativeDate(new Date(nextResetDate))}
        </p>
      )}
    </div>
  );
}
</file>

<file path="src/features/dashboard/context/dashboard-context.tsx">
'use client';

import { createContext, useContext, useReducer, type ReactNode } from 'react';

interface DashboardState {
  currentPage: number;
  pageSize: number;
  isUpgradeModalOpen: boolean;
}

type DashboardAction =
  | { type: 'SET_PAGE'; payload: number }
  | { type: 'SET_PAGE_SIZE'; payload: number }
  | { type: 'OPEN_UPGRADE_MODAL' }
  | { type: 'CLOSE_UPGRADE_MODAL' }
  | { type: 'RESET_PAGINATION' };

const initialState: DashboardState = {
  currentPage: 1,
  pageSize: 10,
  isUpgradeModalOpen: false,
};

function dashboardReducer(state: DashboardState, action: DashboardAction): DashboardState {
  switch (action.type) {
    case 'SET_PAGE':
      return { ...state, currentPage: action.payload };
    case 'SET_PAGE_SIZE':
      return { ...state, pageSize: action.payload, currentPage: 1 };
    case 'OPEN_UPGRADE_MODAL':
      return { ...state, isUpgradeModalOpen: true };
    case 'CLOSE_UPGRADE_MODAL':
      return { ...state, isUpgradeModalOpen: false };
    case 'RESET_PAGINATION':
      return { ...state, currentPage: 1 };
    default:
      return state;
  }
}

interface DashboardContextValue {
  state: DashboardState;
  dispatch: React.Dispatch<DashboardAction>;
}

const DashboardContext = createContext<DashboardContextValue | undefined>(undefined);

export function DashboardProvider({ children }: { children: ReactNode }) {
  const [state, dispatch] = useReducer(dashboardReducer, initialState);

  return (
    <DashboardContext.Provider value={{ state, dispatch }}>
      {children}
    </DashboardContext.Provider>
  );
}

export function useDashboard() {
  const context = useContext(DashboardContext);
  if (!context) {
    throw new Error('useDashboard must be used within DashboardProvider');
  }
  return context;
}
</file>

<file path="src/features/dashboard/lib/dto.ts">
export type { UsageInfoResponse } from '../backend/schema';
</file>

<file path="src/features/example/backend/error.ts">
export const exampleErrorCodes = {
  notFound: 'EXAMPLE_NOT_FOUND',
  fetchError: 'EXAMPLE_FETCH_ERROR',
  validationError: 'EXAMPLE_VALIDATION_ERROR',
} as const;

type ExampleErrorValue = (typeof exampleErrorCodes)[keyof typeof exampleErrorCodes];

export type ExampleServiceError = ExampleErrorValue;
</file>

<file path="src/features/example/backend/route.ts">
import type { Hono } from 'hono';
import {
  failure,
  respond,
  type ErrorResult,
} from '@/backend/http/response';
import {
  getLogger,
  getSupabase,
  type AppEnv,
} from '@/backend/hono/context';
import { ExampleParamsSchema } from '@/features/example/backend/schema';
import { getExampleById } from './service';
import {
  exampleErrorCodes,
  type ExampleServiceError,
} from './error';

export const registerExampleRoutes = (app: Hono<AppEnv>) => {
  app.get('/example/:id', async (c) => {
    const parsedParams = ExampleParamsSchema.safeParse({ id: c.req.param('id') });

    if (!parsedParams.success) {
      return respond(
        c,
        failure(
          400,
          'INVALID_EXAMPLE_PARAMS',
          'The provided example id is invalid.',
          parsedParams.error.format(),
        ),
      );
    }

    const supabase = getSupabase(c);
    const logger = getLogger(c);

    const result = await getExampleById(supabase, parsedParams.data.id);

    if (!result.ok) {
      const errorResult = result as ErrorResult<ExampleServiceError, unknown>;

      if (errorResult.error.code === exampleErrorCodes.fetchError) {
        logger.error('Failed to fetch example', errorResult.error.message);
      }

      return respond(c, result);
    }

    return respond(c, result);
  });
};
</file>

<file path="src/features/example/backend/schema.ts">
import { z } from 'zod';

export const ExampleParamsSchema = z.object({
  id: z.string().uuid({ message: 'Example id must be a valid UUID.' }),
});

export const ExampleResponseSchema = z.object({
  id: z.string().uuid(),
  fullName: z.string(),
  avatarUrl: z.string().url(),
  bio: z.string().nullable(),
  updatedAt: z.string(),
});

export type ExampleResponse = z.infer<typeof ExampleResponseSchema>;

export const ExampleTableRowSchema = z.object({
  id: z.string().uuid(),
  full_name: z.string().nullable(),
  avatar_url: z.string().nullable(),
  bio: z.string().nullable(),
  updated_at: z.string(),
});

export type ExampleRow = z.infer<typeof ExampleTableRowSchema>;
</file>

<file path="src/features/example/backend/service.ts">
import type { SupabaseClient } from '@supabase/supabase-js';
import {
  failure,
  success,
  type HandlerResult,
} from '@/backend/http/response';
import {
  ExampleResponseSchema,
  ExampleTableRowSchema,
  type ExampleResponse,
  type ExampleRow,
} from '@/features/example/backend/schema';
import {
  exampleErrorCodes,
  type ExampleServiceError,
} from '@/features/example/backend/error';

const EXAMPLE_TABLE = 'example';

const fallbackAvatar = (id: string) =>
  `https://picsum.photos/seed/${encodeURIComponent(id)}/200/200`;

export const getExampleById = async (
  client: SupabaseClient,
  id: string,
): Promise<HandlerResult<ExampleResponse, ExampleServiceError, unknown>> => {
  const { data, error } = await client
    .from(EXAMPLE_TABLE)
    .select('id, full_name, avatar_url, bio, updated_at')
    .eq('id', id)
    .maybeSingle<ExampleRow>();

  if (error) {
    return failure(500, exampleErrorCodes.fetchError, error.message);
  }

  if (!data) {
    return failure(404, exampleErrorCodes.notFound, 'Example not found');
  }

  const rowParse = ExampleTableRowSchema.safeParse(data);

  if (!rowParse.success) {
    return failure(
      500,
      exampleErrorCodes.validationError,
      'Example row failed validation.',
      rowParse.error.format(),
    );
  }

  const mapped = {
    id: rowParse.data.id,
    fullName: rowParse.data.full_name ?? 'Anonymous User',
    avatarUrl:
      rowParse.data.avatar_url ?? fallbackAvatar(rowParse.data.id),
    bio: rowParse.data.bio,
    updatedAt: rowParse.data.updated_at,
  } satisfies ExampleResponse;

  const parsed = ExampleResponseSchema.safeParse(mapped);

  if (!parsed.success) {
    return failure(
      500,
      exampleErrorCodes.validationError,
      'Example payload failed validation.',
      parsed.error.format(),
    );
  }

  return success(parsed.data);
};
</file>

<file path="src/features/example/components/example-status.tsx">
'use client';

import { useState } from 'react';
import type { FormEvent } from 'react';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { useExampleQuery } from '@/features/example/hooks/useExampleQuery';

const statusBadge = (
  label: string,
  tone: 'success' | 'error' | 'idle',
) => {
  const toneStyles: Record<typeof tone, string> = {
    success: 'bg-emerald-500/10 text-emerald-300 border-emerald-400/40',
    error: 'bg-rose-500/10 text-rose-300 border-rose-400/40',
    idle: 'bg-slate-500/10 text-slate-200 border-slate-400/30',
  };

  return (
    <span
      className={`inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-medium ${toneStyles[tone]}`}
    >
      {label}
    </span>
  );
};

export const ExampleStatus = () => {
  const [inputValue, setInputValue] = useState('');
  const [exampleId, setExampleId] = useState('');
  const query = useExampleQuery(exampleId);

  const handleSubmit = (event: FormEvent<HTMLFormElement>) => {
    event.preventDefault();
    const trimmed = inputValue.trim();

    if (!trimmed) {
      setExampleId('');
      return;
    }

    if (trimmed === exampleId) {
      void query.refetch();
      return;
    }

    setExampleId(trimmed);
  };

  return (
    <section className="mx-auto flex w-full max-w-3xl flex-col gap-6">
      <header className="space-y-2 text-slate-100">
        <h1 className="text-3xl font-semibold tracking-tight">Backend Health Check</h1>
        <p className="text-sm text-slate-300">
          예시 API(`/api/example/:id`)가 정상 동작하는지 확인합니다. Supabase 예시
          레코드의 UUID를 입력하면 React Query를 통해 백엔드 응답을 확인할 수
          있습니다.
        </p>
      </header>

      <form
        onSubmit={handleSubmit}
        className="flex flex-col gap-3 rounded-xl border border-slate-800 bg-slate-950/60 p-4 md:flex-row md:items-center"
      >
        <div className="flex-1 space-y-1">
          <label className="text-xs uppercase tracking-wide text-slate-400">
            Example UUID
          </label>
          <Input
            value={inputValue}
            onChange={(event) => setInputValue(event.target.value)}
            placeholder="00000000-0000-0000-0000-000000000000"
            className="bg-slate-900/70 text-slate-100 placeholder:text-slate-600"
          />
        </div>
        <Button
          type="submit"
          variant="secondary"
          className="mt-2 h-12 rounded-lg border border-slate-600 bg-slate-800 text-slate-100 hover:bg-slate-700 md:mt-6"
        >
          조회하기
        </Button>
      </form>

      <article className="space-y-3 rounded-xl border border-slate-800 bg-slate-950/60 p-6 text-slate-100">
        <div className="flex items-center justify-between">
          <h2 className="text-lg font-semibold">현재 상태</h2>
          {exampleId
            ? query.status === 'pending'
              ? statusBadge('Fetching', 'idle')
              : query.status === 'error'
                ? statusBadge('Error', 'error')
                : statusBadge('Success', 'success')
            : statusBadge('Idle', 'idle')}
        </div>

        {!exampleId && (
          <p className="text-sm text-slate-300">
            UUID를 입력하고 조회하기 버튼을 누르면 결과가 이곳에 표시됩니다.
          </p>
        )}

        {exampleId && query.status === 'pending' && (
          <p className="text-sm text-slate-300">Supabase에서 데이터를 가져오는 중...</p>
        )}

        {query.status === 'error' && (
          <div className="space-y-2 rounded-lg border border-rose-400/30 bg-rose-500/5 p-4">
            <p className="text-sm font-medium text-rose-300">요청 실패</p>
            <p className="text-xs text-rose-200/80">
              {query.error instanceof Error
                ? query.error.message
                : '알 수 없는 에러가 발생했습니다.'}
            </p>
          </div>
        )}

        {query.data && (
          <div className="space-y-3 rounded-lg border border-emerald-400/30 bg-emerald-500/5 p-4 text-sm text-emerald-100">
            <div>
              <p className="text-xs uppercase tracking-wide text-emerald-300">ID</p>
              <p className="font-mono text-xs md:text-sm">{query.data.id}</p>
            </div>
            <div>
              <p className="text-xs uppercase tracking-wide text-emerald-300">
                이름
              </p>
              <p>{query.data.fullName}</p>
            </div>
            <div>
              <p className="text-xs uppercase tracking-wide text-emerald-300">
                소개
              </p>
              <p>{query.data.bio ?? '—'}</p>
            </div>
            <div>
              <p className="text-xs uppercase tracking-wide text-emerald-300">
                아바타
              </p>
              <a
                href={query.data.avatarUrl}
                target="_blank"
                rel="noreferrer"
                className="underline"
              >
                {query.data.avatarUrl}
              </a>
            </div>
            <div>
              <p className="text-xs uppercase tracking-wide text-emerald-300">
                업데이트 시각
              </p>
              <p>{query.data.updatedAt}</p>
            </div>
          </div>
        )}
      </article>
    </section>
  );
};
</file>

<file path="src/features/example/hooks/useExampleQuery.ts">
'use client';

import { useQuery } from '@tanstack/react-query';
import { apiClient, extractApiErrorMessage } from '@/lib/remote/api-client';
import { ExampleResponseSchema } from '@/features/example/lib/dto';

const fetchExample = async (id: string) => {
  try {
    const { data } = await apiClient.get(`/api/example/${id}`);
    return ExampleResponseSchema.parse(data);
  } catch (error) {
    const message = extractApiErrorMessage(error, 'Failed to fetch example.');
    throw new Error(message);
  }
};

export const useExampleQuery = (id: string) =>
  useQuery({
    queryKey: ['example', id],
    queryFn: () => fetchExample(id),
    enabled: Boolean(id),
    staleTime: 60 * 1000,
  });
</file>

<file path="src/features/example/lib/dto.ts">
export {
  ExampleParamsSchema,
  ExampleResponseSchema,
  type ExampleResponse,
} from '@/features/example/backend/schema';
</file>

<file path="src/features/landing/components/cta-button.tsx">
'use client';

import { useRouter } from 'next/navigation';
import { Button } from '@/components/ui/button';
import { APP_CONFIG } from '@/constants/app';
import { cn } from '@/lib/utils';

interface CTAButtonProps {
  isSignedIn: boolean;
  variant?: 'default' | 'outline' | 'ghost';
  size?: 'default' | 'sm' | 'lg';
  className?: string;
}

export function CTAButton({
  isSignedIn,
  variant = 'default',
  size = 'default',
  className,
}: CTAButtonProps) {
  const router = useRouter();

  const handleClick = () => {
    if (isSignedIn) {
      router.push(APP_CONFIG.routes.dashboard);
    } else {
      router.push(APP_CONFIG.routes.signUp);
    }
  };

  return (
    <Button
      onClick={handleClick}
      variant={variant}
      size={size}
      className={cn(className)}
    >
      {isSignedIn ? '대시보드로 가기' : '무료로 시작하기'}
    </Button>
  );
}
</file>

<file path="src/features/landing/components/cta-section.tsx">
'use client';

import { CTAButton } from './cta-button';

interface CTASectionProps {
  isSignedIn: boolean;
}

export function CTASection({ isSignedIn }: CTASectionProps) {
  return (
    <section className="bg-primary/5 py-24">
      <div className="container mx-auto px-4 text-center">
        <h2 className="mb-6 text-4xl font-bold">
          지금 바로 당신의 사주를 분석해보세요
        </h2>
        <CTAButton isSignedIn={isSignedIn} variant="default" size="lg" />
      </div>
    </section>
  );
}
</file>

<file path="src/features/landing/components/features-section.tsx">
'use client';

import * as LucideIcons from 'lucide-react';
import { LANDING_CONTENT } from '@/constants/landing';
import { Card, CardHeader, CardTitle, CardDescription } from '@/components/ui/card';

export function FeaturesSection() {
  return (
    <section className="container mx-auto px-4 py-16">
      <h2 className="mb-12 text-center text-3xl font-bold">주요 특징</h2>
      <div className="grid gap-6 md:grid-cols-3">
        {LANDING_CONTENT.features.map((feature) => (
          <FeatureCard key={feature.title} {...feature} />
        ))}
      </div>
    </section>
  );
}

interface FeatureCardProps {
  icon: string;
  title: string;
  description: string;
}

function FeatureCard({ icon, title, description }: FeatureCardProps) {
  const IconComponent = LucideIcons[icon as keyof typeof LucideIcons] as React.ComponentType<{ className?: string }>;

  return (
    <Card>
      <CardHeader className="text-center">
        <div className="mx-auto mb-4 flex h-12 w-12 items-center justify-center rounded-lg bg-primary/10">
          <IconComponent className="h-6 w-6 text-primary" />
        </div>
        <CardTitle>{title}</CardTitle>
        <CardDescription>{description}</CardDescription>
      </CardHeader>
    </Card>
  );
}
</file>

<file path="src/features/landing/components/footer.tsx">
'use client';

import { APP_CONFIG } from '@/constants/app';

export function Footer() {
  return (
    <footer className="border-t bg-muted/40 py-8">
      <div className="container mx-auto px-4 text-center text-sm text-muted-foreground">
        © {new Date().getFullYear()} {APP_CONFIG.name}. All rights reserved.
      </div>
    </footer>
  );
}
</file>

<file path="src/features/landing/components/header.tsx">
'use client';

import { useState } from 'react';
import Link from 'next/link';
import { Menu } from 'lucide-react';
import { SignOutButton } from '@clerk/nextjs';
import { APP_CONFIG } from '@/constants/app';
import { Button } from '@/components/ui/button';
import { MobileMenu } from './mobile-menu';

interface HeaderProps {
  isSignedIn: boolean;
}

export function Header({ isSignedIn }: HeaderProps) {
  const [isMobileMenuOpen, setIsMobileMenuOpen] = useState(false);

  return (
    <header className="border-b bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60">
      <div className="container mx-auto flex h-16 items-center justify-between px-4">
        {/* 로고 */}
        <Link href={APP_CONFIG.routes.home} className="text-xl font-bold">
          {APP_CONFIG.name}
        </Link>

        {/* 데스크톱 네비게이션 */}
        <nav className="hidden items-center gap-4 md:flex">
          {isSignedIn ? (
            <>
              <Link href={APP_CONFIG.routes.dashboard}>
                <Button variant="ghost">대시보드</Button>
              </Link>
              <SignOutButton redirectUrl={APP_CONFIG.routes.home}>
                <Button variant="outline">로그아웃</Button>
              </SignOutButton>
            </>
          ) : (
            <>
              <Link href={APP_CONFIG.routes.signIn}>
                <Button variant="ghost">로그인</Button>
              </Link>
              <Link href={APP_CONFIG.routes.signUp}>
                <Button>회원가입</Button>
              </Link>
            </>
          )}
        </nav>

        {/* 모바일 햄버거 버튼 */}
        <button
          className="md:hidden"
          onClick={() => setIsMobileMenuOpen(!isMobileMenuOpen)}
          aria-label="모바일 메뉴 열기"
        >
          <Menu className="h-6 w-6" />
        </button>
      </div>

      {/* 모바일 메뉴 오버레이 */}
      {isMobileMenuOpen && (
        <MobileMenu
          isSignedIn={isSignedIn}
          onClose={() => setIsMobileMenuOpen(false)}
        />
      )}
    </header>
  );
}
</file>

<file path="src/features/landing/components/hero-section.tsx">
'use client';

import { LANDING_CONTENT } from '@/constants/landing';
import { CTAButton } from './cta-button';

interface HeroSectionProps {
  isSignedIn: boolean;
}

export function HeroSection({ isSignedIn }: HeroSectionProps) {
  return (
    <section className="container mx-auto px-4 py-24 text-center">
      <h1 className="mb-6 text-5xl font-bold tracking-tight md:text-6xl">
        {LANDING_CONTENT.hero.title}
      </h1>
      <p className="mb-10 text-xl text-muted-foreground md:text-2xl">
        {LANDING_CONTENT.hero.subtitle}
      </p>
      <CTAButton isSignedIn={isSignedIn} variant="default" size="lg" />
    </section>
  );
}
</file>

<file path="src/features/landing/components/mobile-menu.tsx">
'use client';

import Link from 'next/link';
import { X } from 'lucide-react';
import { SignOutButton } from '@clerk/nextjs';
import { APP_CONFIG } from '@/constants/app';
import { Button } from '@/components/ui/button';

interface MobileMenuProps {
  isSignedIn: boolean;
  onClose: () => void;
}

export function MobileMenu({ isSignedIn, onClose }: MobileMenuProps) {
  return (
    <div className="fixed inset-0 z-50 bg-background/95 backdrop-blur md:hidden">
      <div className="container flex h-full flex-col px-4 py-6">
        {/* 닫기 버튼 */}
        <div className="flex justify-end">
          <button onClick={onClose} aria-label="메뉴 닫기">
            <X className="h-6 w-6" />
          </button>
        </div>

        {/* 메뉴 링크 */}
        <nav className="mt-8 flex flex-col gap-4">
          {isSignedIn ? (
            <>
              <Link href={APP_CONFIG.routes.dashboard} onClick={onClose}>
                <Button variant="ghost" className="w-full justify-start">
                  대시보드
                </Button>
              </Link>
              <SignOutButton redirectUrl={APP_CONFIG.routes.home}>
                <Button variant="outline" className="w-full" onClick={onClose}>
                  로그아웃
                </Button>
              </SignOutButton>
            </>
          ) : (
            <>
              <Link href={APP_CONFIG.routes.signIn} onClick={onClose}>
                <Button variant="ghost" className="w-full justify-start">
                  로그인
                </Button>
              </Link>
              <Link href={APP_CONFIG.routes.signUp} onClick={onClose}>
                <Button className="w-full">회원가입</Button>
              </Link>
            </>
          )}
        </nav>
      </div>
    </div>
  );
}
</file>

<file path="src/features/landing/components/pricing-section.tsx">
'use client';

import { Check } from 'lucide-react';
import { LANDING_CONTENT } from '@/constants/landing';
import { Card, CardHeader, CardTitle, CardContent } from '@/components/ui/card';
import { cn } from '@/lib/utils';

export function PricingSection() {
  return (
    <section className="container mx-auto px-4 py-16">
      <h2 className="mb-12 text-center text-3xl font-bold">가격 안내</h2>
      <div className="mx-auto grid max-w-4xl gap-6 md:grid-cols-2">
        {LANDING_CONTENT.pricing.map((plan) => (
          <PricingCard key={plan.tier} {...plan} />
        ))}
      </div>
    </section>
  );
}

interface PricingCardProps {
  tier: 'free' | 'pro';
  name: string;
  price: number;
  features: readonly string[];
}

function PricingCard({ tier, name, price, features }: PricingCardProps) {
  const isPro = tier === 'pro';

  return (
    <Card className={cn(isPro && 'border-primary shadow-lg')}>
      <CardHeader>
        <CardTitle className="text-2xl">{name}</CardTitle>
        <div className="mt-4 text-4xl font-bold">
          {price === 0 ? (
            '무료'
          ) : (
            <>
              ₩{price.toLocaleString()}
              <span className="text-sm font-normal text-muted-foreground">/월</span>
            </>
          )}
        </div>
      </CardHeader>
      <CardContent>
        <ul className="space-y-3">
          {features.map((feature) => (
            <li key={feature} className="flex items-start gap-2">
              <Check className="mt-0.5 h-5 w-5 text-primary" />
              <span>{feature}</span>
            </li>
          ))}
        </ul>
      </CardContent>
    </Card>
  );
}
</file>

<file path="src/features/subscription/backend/error.ts">
export const subscriptionErrorCodes = {
  subscriptionNotFound: 'SUBSCRIPTION_NOT_FOUND',
  subscriptionAlreadyActive: 'SUBSCRIPTION_ALREADY_ACTIVE',
  subscriptionAlreadyCanceled: 'SUBSCRIPTION_ALREADY_CANCELED',
  subscriptionExpired: 'SUBSCRIPTION_EXPIRED',
  subscriptionNotActive: 'SUBSCRIPTION_NOT_ACTIVE',
  billingKeyIssueFailed: 'BILLING_KEY_ISSUE_FAILED',
  paymentApprovalFailed: 'PAYMENT_APPROVAL_FAILED',
  billingKeyDeleteFailed: 'BILLING_KEY_DELETE_FAILED',
  tosspaymentsApiError: 'TOSSPAYMENTS_API_ERROR',
} as const;

type SubscriptionErrorValue =
  (typeof subscriptionErrorCodes)[keyof typeof subscriptionErrorCodes];

export type SubscriptionServiceError = SubscriptionErrorValue;
</file>

<file path="src/features/subscription/backend/schema.ts">
import { z } from 'zod';

export const subscriptionSchema = z.object({
  id: z.string().uuid(),
  plan: z.enum(['free', 'pro']),
  status: z.enum(['active', 'canceled', 'expired']),
  billingKey: z.string().optional(),
  customerKey: z.string().optional(),
  startedAt: z.string().datetime().optional(),
  nextBillingDate: z.string().datetime().optional(),
  canceledAt: z.string().datetime().optional(),
});

export type Subscription = z.infer<typeof subscriptionSchema>;

export const usageInfoSchema = z.object({
  used: z.number().int().min(0),
  limit: z.number().int().min(1),
  remaining: z.number().int().min(0),
  nextResetDate: z.string().datetime().optional(),
});

export type UsageInfo = z.infer<typeof usageInfoSchema>;

export const paymentHistorySchema = z.object({
  id: z.string().uuid(),
  paymentKey: z.string(),
  orderId: z.string(),
  amount: z.number().int().min(0),
  status: z.enum(['DONE', 'ABORTED', 'CANCELED']),
  paidAt: z.string().datetime(),
});

export type PaymentHistory = z.infer<typeof paymentHistorySchema>;

export const subscribeRequestSchema = z.object({
  authKey: z.string().min(1, '인증 키가 필요합니다'),
});

export type SubscribeRequest = z.infer<typeof subscribeRequestSchema>;

export const cancelRequestSchema = z.object({
  reason: z.string().optional(),
});

export type CancelRequest = z.infer<typeof cancelRequestSchema>;

export const resumeRequestSchema = z.object({});

export type ResumeRequest = z.infer<typeof resumeRequestSchema>;

export const subscriptionRowSchema = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  plan: z.enum(['free', 'pro']),
  status: z.enum(['active', 'canceled', 'expired']),
  billing_key: z.string().nullable(),
  customer_key: z.string().nullable(),
  started_at: z.string().nullable(),
  next_billing_date: z.string().nullable(),
  canceled_at: z.string().nullable(),
  created_at: z.string(),
  updated_at: z.string(),
});

export type SubscriptionRow = z.infer<typeof subscriptionRowSchema>;

export const paymentHistoryRowSchema = z.object({
  id: z.string().uuid(),
  user_id: z.string().uuid(),
  payment_key: z.string(),
  order_id: z.string(),
  amount: z.number().int(),
  status: z.enum(['DONE', 'ABORTED', 'CANCELED']),
  paid_at: z.string(),
  created_at: z.string(),
});

export type PaymentHistoryRow = z.infer<typeof paymentHistoryRowSchema>;
</file>

<file path="src/features/subscription/backend/service.ts">
import type { SupabaseClient } from '@supabase/supabase-js';
import { addMonths } from 'date-fns';
import type { Subscription, PaymentHistory, UsageInfo } from './schema';
import { subscriptionRowSchema, paymentHistoryRowSchema } from './schema';
import { subscriptionErrorCodes } from './error';
import {
  issueBillingKey,
  approveBilling,
  deleteBillingKey,
  TOSS_CONSTANTS,
} from '@/backend/integrations/tosspayments/client';
import { checkUsageLimit } from '@/backend/services/usage';

export async function getSubscription(
  supabase: SupabaseClient,
  userId: string
): Promise<Subscription | null> {
  const { data, error } = await supabase
    .from('subscriptions')
    .select('*')
    .eq('user_id', userId)
    .in('status', ['active', 'canceled'])
    .single();

  if (error || !data) {
    return null;
  }

  const row = subscriptionRowSchema.parse(data);

  return {
    id: row.id,
    plan: row.plan,
    status: row.status,
    billingKey: row.billing_key ?? undefined,
    customerKey: row.customer_key ?? undefined,
    startedAt: row.started_at ?? undefined,
    nextBillingDate: row.next_billing_date ?? undefined,
    canceledAt: row.canceled_at ?? undefined,
  };
}

export async function getUsageInfo(
  supabase: SupabaseClient,
  userId: string
): Promise<UsageInfo> {
  const usage = await checkUsageLimit(supabase, userId);

  return {
    used: usage.used,
    limit: usage.limit,
    remaining: usage.remaining,
    nextResetDate: usage.nextResetDate?.toISOString(),
  };
}

export async function getPaymentHistories(
  supabase: SupabaseClient,
  userId: string,
  page: number = 1,
  limit: number = 10
): Promise<PaymentHistory[]> {
  const offset = (page - 1) * limit;

  const { data, error } = await supabase
    .from('payment_histories')
    .select('*')
    .eq('user_id', userId)
    .order('paid_at', { ascending: false })
    .range(offset, offset + limit - 1);

  if (error || !data) {
    return [];
  }

  return data.map((row) => {
    const parsed = paymentHistoryRowSchema.parse(row);
    return {
      id: parsed.id,
      paymentKey: parsed.payment_key,
      orderId: parsed.order_id,
      amount: parsed.amount,
      status: parsed.status,
      paidAt: parsed.paid_at,
    };
  });
}

export async function createProSubscription(
  supabase: SupabaseClient,
  userId: string,
  authKey: string,
  secretKey: string
): Promise<void> {
  const existingSub = await getSubscription(supabase, userId);

  if (existingSub && existingSub.status === 'active') {
    const error = new Error('이미 활성 구독이 있습니다');
    (error as any).code = subscriptionErrorCodes.subscriptionAlreadyActive;
    throw error;
  }

  let billingKey: string | null = null;

  try {
    const customerKey = userId;
    const orderId = `order_${Date.now()}_${userId.slice(0, 8)}`;

    const { billingKey: issuedKey } = await issueBillingKey(
      authKey,
      customerKey,
      secretKey
    );
    billingKey = issuedKey;

    const { paymentKey, approvedAt } = await approveBilling(
      billingKey,
      TOSS_CONSTANTS.PRO_PRICE,
      orderId,
      TOSS_CONSTANTS.ORDER_NAME,
      secretKey
    );

    const now = new Date();
    const nextBillingDate = addMonths(now, 1);

    const { error: userError } = await supabase
      .from('users')
      .update({ subscription_tier: 'pro' })
      .eq('id', userId);

    if (userError) {
      throw userError;
    }

    const { error: subError } = await supabase.from('subscriptions').insert({
      user_id: userId,
      plan: 'pro',
      status: 'active',
      billing_key: billingKey,
      customer_key: customerKey,
      started_at: now.toISOString(),
      next_billing_date: nextBillingDate.toISOString(),
    });

    if (subError) {
      throw subError;
    }

    const { error: paymentError } = await supabase
      .from('payment_histories')
      .insert({
        user_id: userId,
        payment_key: paymentKey,
        order_id: orderId,
        amount: TOSS_CONSTANTS.PRO_PRICE,
        status: 'DONE',
        paid_at: approvedAt.toISOString(),
      });

    if (paymentError) {
      throw paymentError;
    }
  } catch (error) {
    if (billingKey) {
      try {
        await deleteBillingKey(billingKey, secretKey);
      } catch {
        // 빌링키 삭제 실패는 무시
      }
    }

    if ((error as any).code) {
      throw error;
    }

    const serviceError = new Error('Pro 구독 생성에 실패했습니다');
    (serviceError as any).code = subscriptionErrorCodes.billingKeyIssueFailed;
    throw serviceError;
  }
}

export async function cancelSubscription(
  supabase: SupabaseClient,
  userId: string,
  reason?: string
): Promise<{ nextBillingDate: Date }> {
  const subscription = await getSubscription(supabase, userId);

  if (!subscription) {
    const error = new Error('구독 정보를 찾을 수 없습니다');
    (error as any).code = subscriptionErrorCodes.subscriptionNotFound;
    throw error;
  }

  if (subscription.status !== 'active') {
    const error = new Error('활성 구독이 아닙니다');
    (error as any).code = subscriptionErrorCodes.subscriptionNotActive;
    throw error;
  }

  const now = new Date();

  const { error } = await supabase
    .from('subscriptions')
    .update({
      status: 'canceled',
      canceled_at: now.toISOString(),
    })
    .eq('id', subscription.id);

  if (error) {
    throw error;
  }

  if (reason) {
    console.log(`Subscription canceled. Reason: ${reason}`);
  }

  return {
    nextBillingDate: new Date(subscription.nextBillingDate!),
  };
}

export async function resumeSubscription(
  supabase: SupabaseClient,
  userId: string
): Promise<{ nextBillingDate: Date }> {
  const subscription = await getSubscription(supabase, userId);

  if (!subscription) {
    const error = new Error('구독 정보를 찾을 수 없습니다');
    (error as any).code = subscriptionErrorCodes.subscriptionNotFound;
    throw error;
  }

  if (subscription.status !== 'canceled') {
    const error = new Error('취소된 구독이 아닙니다');
    (error as any).code = subscriptionErrorCodes.subscriptionAlreadyActive;
    throw error;
  }

  const now = new Date();
  const nextBillingDate = new Date(subscription.nextBillingDate!);

  if (nextBillingDate <= now) {
    const error = new Error('구독이 이미 만료되었습니다');
    (error as any).code = subscriptionErrorCodes.subscriptionExpired;
    throw error;
  }

  const { error } = await supabase
    .from('subscriptions')
    .update({
      status: 'active',
      canceled_at: null,
    })
    .eq('id', subscription.id);

  if (error) {
    throw error;
  }

  return {
    nextBillingDate,
  };
}
</file>

<file path="src/features/subscription/backend/webhook.ts">
import type { Hono } from 'hono';
import type { AppEnv } from '@/backend/hono/context';
import { verifyWebhookSignature } from '@/backend/integrations/tosspayments/client';

export const registerWebhookRoutes = (app: Hono<AppEnv>) => {
  app.post('/api/webhooks/tosspayments', async (c) => {
    const payload = await c.req.text();
    const signature = c.req.header('X-Toss-Signature');
    const config = c.get('config');
    const logger = c.get('logger');

    if (
      !signature ||
      !verifyWebhookSignature(payload, signature, config.toss.webhookSecret)
    ) {
      logger.warn('Invalid webhook signature');
      return c.json({ error: 'Invalid signature' }, 401);
    }

    const event = JSON.parse(payload);
    const supabase = c.get('supabase');

    switch (event.eventType) {
      case 'PAYMENT_STATUS_CHANGED':
        await handlePaymentStatusChanged(supabase, event, logger);
        break;
      default:
        logger.info('Unknown webhook event type', { eventType: event.eventType });
    }

    return c.json({ success: true });
  });
};

async function handlePaymentStatusChanged(
  supabase: any,
  event: any,
  logger: any
) {
  const { orderId, status, paymentKey, amount, approvedAt } = event.data;

  const { data: existing } = await supabase
    .from('payment_histories')
    .select('id')
    .eq('order_id', orderId)
    .single();

  if (existing) {
    logger.info('Duplicate webhook event', { orderId });
    return;
  }

  const { data: user } = await supabase
    .from('users')
    .select('id')
    .limit(1)
    .single();

  if (!user) {
    logger.error('User not found for payment', { orderId });
    return;
  }

  await supabase.from('payment_histories').insert({
    user_id: user.id,
    payment_key: paymentKey,
    order_id: orderId,
    amount,
    status,
    paid_at: approvedAt,
  });

  if (status === 'ABORTED') {
    logger.warn('Payment failed', { orderId });
  }
}
</file>

<file path="src/features/subscription/components/cancel-button.tsx">
'use client';

import { Button } from '@/components/ui/button';
import { useSubscriptionContext } from '../context/subscription-context';

export function CancelButton() {
  const { openCancelModal, canCancel } = useSubscriptionContext();

  if (!canCancel) {
    return null;
  }

  return (
    <Button variant="outline" onClick={openCancelModal} className="w-full">
      구독 취소
    </Button>
  );
}
</file>

<file path="src/features/subscription/components/cancel-modal.tsx">
'use client';

import { format } from 'date-fns';
import { ko } from 'date-fns/locale';
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from '@/components/ui/dialog';
import { Button } from '@/components/ui/button';
import { Label } from '@/components/ui/label';
import { RadioGroup, RadioGroupItem } from '@/components/ui/radio-group';
import { useSubscriptionContext } from '../context/subscription-context';

const CANCEL_REASONS = [
  { value: 'expensive', label: '가격이 비싸요' },
  { value: 'not_useful', label: '서비스가 유용하지 않아요' },
  { value: 'alternative', label: '다른 서비스를 사용해요' },
  { value: 'temporary', label: '잠시 사용하지 않을 예정이에요' },
  { value: 'other', label: '기타' },
];

export function CancelModal() {
  const { state, closeCancelModal, handleCancel, setCancelReason, subscription } =
    useSubscriptionContext();

  if (!subscription?.nextBillingDate) {
    return null;
  }

  return (
    <Dialog open={state.cancelModalOpen} onOpenChange={closeCancelModal}>
      <DialogContent>
        <DialogHeader>
          <DialogTitle>구독을 취소하시겠습니까?</DialogTitle>
          <DialogDescription>
            구독을 취소하셔도{' '}
            <strong>{format(new Date(subscription.nextBillingDate), 'PPP', { locale: ko })}</strong>
            까지는 Pro 혜택을 계속 이용하실 수 있습니다.
          </DialogDescription>
        </DialogHeader>

        <div className="space-y-4">
          <div>
            <Label>취소 사유를 선택해주세요 (선택사항)</Label>
            <RadioGroup
              value={state.selectedReason ?? undefined}
              onValueChange={(value) => setCancelReason(value)}
              className="mt-2"
            >
              {CANCEL_REASONS.map((reason) => (
                <div key={reason.value} className="flex items-center space-x-2">
                  <RadioGroupItem value={reason.value} id={reason.value} />
                  <Label htmlFor={reason.value} className="font-normal cursor-pointer">
                    {reason.label}
                  </Label>
                </div>
              ))}
            </RadioGroup>
          </div>
        </div>

        <DialogFooter>
          <Button variant="outline" onClick={closeCancelModal}>
            돌아가기
          </Button>
          <Button variant="destructive" onClick={handleCancel}>
            구독 취소
          </Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="src/features/subscription/components/expired-view.tsx">
'use client';

import { AlertCircle } from 'lucide-react';
import { Badge } from '@/components/ui/badge';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { SubscribeButton } from './subscribe-button';

export function ExpiredView() {
  return (
    <div className="container mx-auto max-w-4xl py-8 space-y-6">
      <div className="space-y-2">
        <div className="flex items-center space-x-2">
          <h1 className="text-3xl font-bold">구독 관리</h1>
          <Badge variant="secondary">만료됨</Badge>
        </div>
        <p className="text-muted-foreground">Pro 구독이 만료되었습니다.</p>
      </div>

      <Card className="border-destructive/50">
        <CardHeader>
          <div className="flex items-center space-x-2">
            <AlertCircle className="h-5 w-5 text-destructive" />
            <CardTitle>구독이 만료되었습니다</CardTitle>
          </div>
          <CardDescription>
            Pro 혜택을 계속 이용하시려면 다시 구독해주세요.
          </CardDescription>
        </CardHeader>
        <CardContent className="space-y-4">
          <div className="rounded-lg bg-muted p-4">
            <p className="text-sm text-muted-foreground">
              현재 무료 체험 상태로 전환되었습니다. 매월 1회 AI 분석을 이용하실 수 있습니다.
            </p>
          </div>

          <SubscribeButton />
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="src/features/subscription/components/free-view.tsx">
'use client';

import { Check } from 'lucide-react';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { APP_CONFIG } from '@/constants/app';
import { SubscribeButton } from './subscribe-button';
import { UsageInfoCard } from './usage-info-card';

export function FreeView() {
  return (
    <div className="container mx-auto max-w-4xl py-8 space-y-6">
      <div className="space-y-2">
        <div className="flex items-center space-x-2">
          <h1 className="text-3xl font-bold">구독 관리</h1>
          <Badge variant="secondary">무료 체험</Badge>
        </div>
        <p className="text-muted-foreground">
          현재 무료 체험 중입니다. Pro로 업그레이드하여 더 많은 혜택을 누리세요.
        </p>
      </div>

      <UsageInfoCard />

      <Card>
        <CardHeader>
          <CardTitle>Pro 요금제</CardTitle>
          <CardDescription>AI 사주 분석을 무제한으로 이용하세요</CardDescription>
        </CardHeader>
        <CardContent className="space-y-6">
          <div className="space-y-4">
            <div className="flex items-center space-x-3">
              <div className="rounded-full bg-primary/10 p-1">
                <Check className="h-4 w-4 text-primary" />
              </div>
              <span className="text-sm">매월 {APP_CONFIG.subscription.pro.limit}회 AI 분석</span>
            </div>
            <div className="flex items-center space-x-3">
              <div className="rounded-full bg-primary/10 p-1">
                <Check className="h-4 w-4 text-primary" />
              </div>
              <span className="text-sm">고급 AI 모델 (Gemini 2.5 Pro) 사용</span>
            </div>
            <div className="flex items-center space-x-3">
              <div className="rounded-full bg-primary/10 p-1">
                <Check className="h-4 w-4 text-primary" />
              </div>
              <span className="text-sm">분석 결과 무제한 저장 및 조회</span>
            </div>
            <div className="flex items-center space-x-3">
              <div className="rounded-full bg-primary/10 p-1">
                <Check className="h-4 w-4 text-primary" />
              </div>
              <span className="text-sm">언제든지 취소 가능</span>
            </div>
          </div>

          <div className="rounded-lg bg-muted p-4">
            <div className="flex items-baseline justify-between">
              <span className="text-sm text-muted-foreground">월 구독료</span>
              <div className="flex items-baseline space-x-1">
                <span className="text-3xl font-bold">
                  {APP_CONFIG.subscription.pro.price.toLocaleString()}
                </span>
                <span className="text-sm text-muted-foreground">원</span>
              </div>
            </div>
          </div>

          <SubscribeButton />
        </CardContent>
      </Card>
    </div>
  );
}
</file>

<file path="src/features/subscription/components/payment-history-list.tsx">
'use client';

import { format } from 'date-fns';
import { ko } from 'date-fns/locale';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { Separator } from '@/components/ui/separator';
import { useSubscriptionContext } from '../context/subscription-context';

export function PaymentHistoryList() {
  const { paymentHistories, isLoadingHistories } = useSubscriptionContext();

  const getStatusLabel = (status: string) => {
    switch (status) {
      case 'DONE':
        return '완료';
      case 'ABORTED':
        return '실패';
      case 'CANCELED':
        return '취소';
      default:
        return status;
    }
  };

  const getStatusVariant = (status: string) => {
    switch (status) {
      case 'DONE':
        return 'default';
      case 'ABORTED':
        return 'destructive';
      case 'CANCELED':
        return 'secondary';
      default:
        return 'outline';
    }
  };

  if (isLoadingHistories) {
    return (
      <Card>
        <CardHeader>
          <CardTitle>결제 이력</CardTitle>
          <CardDescription>과거 결제 내역을 확인하세요</CardDescription>
        </CardHeader>
        <CardContent>
          <p className="text-sm text-muted-foreground">로딩 중...</p>
        </CardContent>
      </Card>
    );
  }

  if (paymentHistories.length === 0) {
    return (
      <Card>
        <CardHeader>
          <CardTitle>결제 이력</CardTitle>
          <CardDescription>과거 결제 내역을 확인하세요</CardDescription>
        </CardHeader>
        <CardContent>
          <p className="text-sm text-muted-foreground">결제 이력이 없습니다.</p>
        </CardContent>
      </Card>
    );
  }

  return (
    <Card>
      <CardHeader>
        <CardTitle>결제 이력</CardTitle>
        <CardDescription>과거 결제 내역을 확인하세요</CardDescription>
      </CardHeader>
      <CardContent>
        <div className="space-y-4">
          {paymentHistories.map((history, index) => (
            <div key={history.id}>
              {index > 0 && <Separator className="my-4" />}
              <div className="flex items-center justify-between">
                <div className="space-y-1">
                  <p className="text-sm font-medium">
                    {format(new Date(history.paidAt), 'PPP', { locale: ko })}
                  </p>
                  <p className="text-sm text-muted-foreground">{history.orderId}</p>
                </div>
                <div className="flex items-center space-x-4">
                  <span className="text-sm font-medium">{history.amount.toLocaleString()}원</span>
                  <Badge variant={getStatusVariant(history.status) as any}>
                    {getStatusLabel(history.status)}
                  </Badge>
                </div>
              </div>
            </div>
          ))}
        </div>
      </CardContent>
    </Card>
  );
}
</file>

<file path="src/features/subscription/components/payment-method-card.tsx">
'use client';

import { CreditCard } from 'lucide-react';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { useSubscriptionContext } from '../context/subscription-context';

export function PaymentMethodCard() {
  const { subscription } = useSubscriptionContext();

  if (!subscription?.billingKey) {
    return null;
  }

  return (
    <Card>
      <CardHeader>
        <CardTitle>결제 수단</CardTitle>
        <CardDescription>등록된 카드 정보</CardDescription>
      </CardHeader>
      <CardContent>
        <div className="flex items-center space-x-4">
          <div className="rounded-full bg-primary/10 p-3">
            <CreditCard className="h-6 w-6 text-primary" />
          </div>
          <div>
            <p className="text-sm font-medium">등록된 카드</p>
            <p className="text-sm text-muted-foreground">자동 결제가 설정되어 있습니다</p>
          </div>
        </div>
      </CardContent>
    </Card>
  );
}
</file>

<file path="src/features/subscription/components/pro-active-view.tsx">
'use client';

import { Badge } from '@/components/ui/badge';
import { SubscriptionInfoCard } from './subscription-info-card';
import { UsageInfoCard } from './usage-info-card';
import { PaymentMethodCard } from './payment-method-card';
import { PaymentHistoryList } from './payment-history-list';
import { CancelButton } from './cancel-button';
import { CancelModal } from './cancel-modal';

export function ProActiveView() {
  return (
    <div className="container mx-auto max-w-4xl py-8 space-y-6">
      <div className="space-y-2">
        <div className="flex items-center space-x-2">
          <h1 className="text-3xl font-bold">구독 관리</h1>
          <Badge>Pro 구독 중</Badge>
        </div>
        <p className="text-muted-foreground">
          Pro 구독을 이용 중입니다. 구독 정보와 사용 현황을 확인하세요.
        </p>
      </div>

      <div className="grid gap-6 md:grid-cols-2">
        <SubscriptionInfoCard />
        <UsageInfoCard />
      </div>

      <PaymentMethodCard />

      <PaymentHistoryList />

      <CancelButton />

      <CancelModal />
    </div>
  );
}
</file>

<file path="src/features/subscription/components/pro-canceled-view.tsx">
'use client';

import { Badge } from '@/components/ui/badge';
import { SubscriptionInfoCard } from './subscription-info-card';
import { UsageInfoCard } from './usage-info-card';
import { ResumeButton } from './resume-button';
import { ResumeModal } from './resume-modal';

export function ProCanceledView() {
  return (
    <div className="container mx-auto max-w-4xl py-8 space-y-6">
      <div className="space-y-2">
        <div className="flex items-center space-x-2">
          <h1 className="text-3xl font-bold">구독 관리</h1>
          <Badge variant="destructive">취소 예정</Badge>
        </div>
        <p className="text-muted-foreground">
          구독이 취소되었습니다. 만료일까지는 Pro 혜택을 계속 이용하실 수 있습니다.
        </p>
      </div>

      <div className="grid gap-6 md:grid-cols-2">
        <SubscriptionInfoCard />
        <UsageInfoCard />
      </div>

      <ResumeButton />

      <ResumeModal />
    </div>
  );
}
</file>

<file path="src/features/subscription/components/resume-button.tsx">
'use client';

import { RefreshCw } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { useSubscriptionContext } from '../context/subscription-context';

export function ResumeButton() {
  const { openResumeModal, canResume } = useSubscriptionContext();

  if (!canResume) {
    return null;
  }

  return (
    <Button onClick={openResumeModal} className="w-full">
      <RefreshCw className="mr-2 h-4 w-4" />
      구독 재개
    </Button>
  );
}
</file>

<file path="src/features/subscription/components/resume-modal.tsx">
'use client';

import { format } from 'date-fns';
import { ko } from 'date-fns/locale';
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from '@/components/ui/dialog';
import { Button } from '@/components/ui/button';
import { useSubscriptionContext } from '../context/subscription-context';

export function ResumeModal() {
  const { state, closeResumeModal, handleResume, subscription } = useSubscriptionContext();

  if (!subscription?.nextBillingDate) {
    return null;
  }

  return (
    <Dialog open={state.resumeModalOpen} onOpenChange={closeResumeModal}>
      <DialogContent>
        <DialogHeader>
          <DialogTitle>구독을 재개하시겠습니까?</DialogTitle>
          <DialogDescription>
            구독을 재개하시면{' '}
            <strong>{format(new Date(subscription.nextBillingDate), 'PPP', { locale: ko })}</strong>
            부터 정기결제가 다시 시작됩니다.
          </DialogDescription>
        </DialogHeader>

        <div className="rounded-lg bg-muted p-4">
          <p className="text-sm text-muted-foreground">
            재개 시 즉시 Pro 혜택을 계속 이용하실 수 있으며, 다음 결제일에 자동으로 결제됩니다.
          </p>
        </div>

        <DialogFooter>
          <Button variant="outline" onClick={closeResumeModal}>
            취소
          </Button>
          <Button onClick={handleResume}>구독 재개</Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );
}
</file>

<file path="src/features/subscription/components/subscribe-button.tsx">
'use client';

import { Sparkles } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { useSubscriptionContext } from '../context/subscription-context';

export function SubscribeButton() {
  const { handleSubscribe, state } = useSubscriptionContext();

  const isProcessing = state.paymentFlow === 'processing';

  return (
    <Button
      size="lg"
      onClick={handleSubscribe}
      disabled={isProcessing}
      className="w-full"
    >
      {isProcessing ? (
        <>처리 중...</>
      ) : (
        <>
          <Sparkles className="mr-2 h-5 w-5" />
          Pro 구독하기
        </>
      )}
    </Button>
  );
}
</file>

<file path="src/features/subscription/components/subscription-content.tsx">
'use client';

import { Loader2 } from 'lucide-react';
import { useSubscriptionContext } from '../context/subscription-context';
import { FreeView } from './free-view';
import { ProActiveView } from './pro-active-view';
import { ProCanceledView } from './pro-canceled-view';
import { ExpiredView } from './expired-view';

export function SubscriptionContent() {
  const { subscriptionTier, isCanceled, isExpired, isLoadingSubscription } =
    useSubscriptionContext();

  if (isLoadingSubscription) {
    return (
      <div className="flex items-center justify-center min-h-screen">
        <Loader2 className="h-8 w-8 animate-spin text-muted-foreground" />
      </div>
    );
  }

  if (isExpired) {
    return <ExpiredView />;
  }

  if (subscriptionTier === 'free') {
    return <FreeView />;
  }

  if (isCanceled) {
    return <ProCanceledView />;
  }

  return <ProActiveView />;
}
</file>

<file path="src/features/subscription/components/subscription-info-card.tsx">
'use client';

import { format } from 'date-fns';
import { ko } from 'date-fns/locale';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { useSubscriptionContext } from '../context/subscription-context';

export function SubscriptionInfoCard() {
  const { subscription, isCanceled, daysUntilExpiry } = useSubscriptionContext();

  if (!subscription) {
    return null;
  }

  const statusVariant = isCanceled ? 'destructive' : 'default';
  const statusLabel = isCanceled ? '취소 예정' : '활성';

  return (
    <Card>
      <CardHeader>
        <div className="flex items-center justify-between">
          <CardTitle>구독 정보</CardTitle>
          <Badge variant={statusVariant}>{statusLabel}</Badge>
        </div>
        <CardDescription>현재 구독 상태를 확인하세요</CardDescription>
      </CardHeader>
      <CardContent className="space-y-4">
        {subscription.startedAt && (
          <div className="flex justify-between">
            <span className="text-sm text-muted-foreground">시작일</span>
            <span className="text-sm font-medium">
              {format(new Date(subscription.startedAt), 'PPP', { locale: ko })}
            </span>
          </div>
        )}

        {subscription.nextBillingDate && (
          <div className="flex justify-between">
            <span className="text-sm text-muted-foreground">
              {isCanceled ? '혜택 만료일' : '다음 결제일'}
            </span>
            <span className="text-sm font-medium">
              {format(new Date(subscription.nextBillingDate), 'PPP', { locale: ko })}
            </span>
          </div>
        )}

        {isCanceled && daysUntilExpiry !== null && (
          <div className="mt-4 rounded-lg bg-destructive/10 p-3">
            <p className="text-sm text-destructive">
              {daysUntilExpiry > 0
                ? `${daysUntilExpiry}일 후 Pro 혜택이 만료됩니다.`
                : '곧 Pro 혜택이 만료됩니다.'}
            </p>
          </div>
        )}
      </CardContent>
    </Card>
  );
}
</file>

<file path="src/features/subscription/components/usage-info-card.tsx">
'use client';

import { format } from 'date-fns';
import { ko } from 'date-fns/locale';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Progress } from '@/components/ui/progress';
import { useSubscriptionContext } from '../context/subscription-context';

export function UsageInfoCard() {
  const { usageInfo, subscriptionTier } = useSubscriptionContext();

  if (!usageInfo) {
    return null;
  }

  const usagePercentage = (usageInfo.used / usageInfo.limit) * 100;

  return (
    <Card>
      <CardHeader>
        <CardTitle>사용 현황</CardTitle>
        <CardDescription>이번 달 AI 분석 사용량</CardDescription>
      </CardHeader>
      <CardContent className="space-y-4">
        <div className="space-y-2">
          <div className="flex justify-between text-sm">
            <span className="text-muted-foreground">사용량</span>
            <span className="font-medium">
              {usageInfo.used} / {usageInfo.limit}회
            </span>
          </div>
          <Progress value={usagePercentage} className="h-2" />
        </div>

        <div className="flex justify-between">
          <span className="text-sm text-muted-foreground">남은 횟수</span>
          <span className="text-sm font-medium">{usageInfo.remaining}회</span>
        </div>

        {subscriptionTier === 'pro' && usageInfo.nextResetDate && (
          <div className="mt-4 rounded-lg bg-muted p-3">
            <p className="text-sm text-muted-foreground">
              다음 초기화: {format(new Date(usageInfo.nextResetDate), 'PPP', { locale: ko })}
            </p>
          </div>
        )}
      </CardContent>
    </Card>
  );
}
</file>

<file path="src/features/subscription/lib/dto.ts">
export type {
  Subscription,
  UsageInfo,
  PaymentHistory,
  SubscribeRequest,
  CancelRequest,
  ResumeRequest,
} from '../backend/schema';
</file>

<file path="src/hooks/use-api-client.ts">
"use client";

import { useAuth } from "@clerk/nextjs";
import { useEffect, useMemo } from "react";
import axios from "axios";

/**
 * Clerk 인증 토큰이 자동으로 포함되는 API 클라이언트를 반환하는 훅
 *
 * @example
 * ```tsx
 * const apiClient = useApiClient();
 * const { data } = await apiClient.get('/api/dashboard/me');
 * ```
 */
export function useApiClient() {
  const { getToken } = useAuth();

  const apiClient = useMemo(() => {
    const client = axios.create({
      baseURL: process.env.NEXT_PUBLIC_API_BASE_URL ?? "",
      headers: {
        "Content-Type": "application/json",
      },
    });

    // 요청 인터셉터: 모든 요청에 Clerk 토큰 추가
    client.interceptors.request.use(
      async (config) => {
        try {
          const token = await getToken();
          if (token) {
            config.headers.Authorization = `Bearer ${token}`;
          }
        } catch (error) {
          console.error("Failed to get Clerk token:", error);
        }
        return config;
      },
      (error) => {
        return Promise.reject(error);
      }
    );

    return client;
  }, [getToken]);

  return apiClient;
}
</file>

<file path="src/hooks/use-toast.ts">
"use client"

// Inspired by react-hot-toast library
import * as React from "react"

import type {
  ToastActionElement,
  ToastProps,
} from "@/components/ui/toast"

const TOAST_LIMIT = 1
const TOAST_REMOVE_DELAY = 1000000

type ToasterToast = ToastProps & {
  id: string
  title?: React.ReactNode
  description?: React.ReactNode
  action?: ToastActionElement
}

const actionTypes = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST",
} as const

let count = 0

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER
  return count.toString()
}

type ActionType = typeof actionTypes

type Action =
  | {
      type: ActionType["ADD_TOAST"]
      toast: ToasterToast
    }
  | {
      type: ActionType["UPDATE_TOAST"]
      toast: Partial<ToasterToast>
    }
  | {
      type: ActionType["DISMISS_TOAST"]
      toastId?: ToasterToast["id"]
    }
  | {
      type: ActionType["REMOVE_TOAST"]
      toastId?: ToasterToast["id"]
    }

interface State {
  toasts: ToasterToast[]
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId)
    dispatch({
      type: "REMOVE_TOAST",
      toastId: toastId,
    })
  }, TOAST_REMOVE_DELAY)

  toastTimeouts.set(toastId, timeout)
}

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      }

    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t
        ),
      }

    case "DISMISS_TOAST": {
      const { toastId } = action

      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId)
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id)
        })
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t
        ),
      }
    }
    case "REMOVE_TOAST":
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        }
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      }
  }
}

const listeners: Array<(state: State) => void> = []

let memoryState: State = { toasts: [] }

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action)
  listeners.forEach((listener) => {
    listener(memoryState)
  })
}

type Toast = Omit<ToasterToast, "id">

function toast({ ...props }: Toast) {
  const id = genId()

  const update = (props: ToasterToast) =>
    dispatch({
      type: "UPDATE_TOAST",
      toast: { ...props, id },
    })
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id })

  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss()
      },
    },
  })

  return {
    id: id,
    dismiss,
    update,
  }
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState)

  React.useEffect(() => {
    listeners.push(setState)
    return () => {
      const index = listeners.indexOf(setState)
      if (index > -1) {
        listeners.splice(index, 1)
      }
    }
  }, [state])

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
  }
}

export { useToast, toast }
</file>

<file path="src/lib/payment/toss.ts">
import { loadTossPayments } from '@tosspayments/payment-sdk';

/**
 * 토스페이먼츠 SDK 래퍼
 */

export interface TossPaymentRequest {
  amount: number;
  orderId: string;
  orderName: string;
  customerKey: string;
  successUrl: string;
  failUrl: string;
}

/**
 * 토스페이먼츠 결제 요청
 *
 * @param request 결제 요청 정보
 * @throws {Error} 클라이언트 키가 설정되지 않은 경우
 */
export async function requestTossPayment(request: TossPaymentRequest) {
  const clientKey = process.env.NEXT_PUBLIC_TOSS_CLIENT_KEY;

  if (!clientKey) {
    throw new Error('NEXT_PUBLIC_TOSS_CLIENT_KEY is not defined');
  }

  const tossPayments = await loadTossPayments(clientKey);

  return tossPayments.requestBillingAuth('카드', {
    customerKey: request.customerKey,
    successUrl: request.successUrl,
    failUrl: request.failUrl,
  });
}
</file>

<file path="src/lib/query/config.ts">
import { QueryClient, type DefaultOptions } from '@tanstack/react-query';

/**
 * React Query 전역 설정
 */

const defaultOptions: DefaultOptions = {
  queries: {
    retry: 3,
    retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 3000),
    staleTime: 5 * 60 * 1000, // 5분
    gcTime: 10 * 60 * 1000, // 10분 (구 cacheTime)
    refetchOnWindowFocus: false,
  },
  mutations: {
    retry: 0,
  },
};

export const createQueryClient = () =>
  new QueryClient({ defaultOptions });
</file>

<file path="src/lib/query/hooks.ts">
import { useMutation, type UseMutationOptions } from '@tanstack/react-query';
import { useToast } from '@/hooks/use-toast';
import { extractApiErrorMessage } from '@/lib/remote/types';

/**
 * React Query 커스텀 훅
 */

/**
 * 뮤테이션 성공/실패 시 토스트 표시
 *
 * @example
 * ```ts
 * const mutation = useMutationWithToast(
 *   (data) => api.post('/endpoint', data),
 *   {
 *     successMessage: '저장되었습니다',
 *     errorMessage: '저장에 실패했습니다',
 *   }
 * );
 * ```
 */
export function useMutationWithToast<TData, TVariables>(
  mutationFn: (variables: TVariables) => Promise<TData>,
  options?: {
    successMessage?: string;
    errorMessage?: string;
    onSuccess?: (data: TData) => void;
    onError?: (error: unknown) => void;
  }
) {
  const { toast } = useToast();

  return useMutation({
    mutationFn,
    onSuccess: (data) => {
      if (options?.successMessage) {
        toast({ title: options.successMessage });
      }
      options?.onSuccess?.(data);
    },
    onError: (error) => {
      const message = extractApiErrorMessage(error, options?.errorMessage);
      toast({ title: message, variant: 'destructive' });
      options?.onError?.(error);
    },
  } as UseMutationOptions<TData, unknown, TVariables>);
}
</file>

<file path="src/lib/remote/types.ts">
/**
 * API 응답 타입 정의
 *
 * 백엔드 응답과 일치하는 타입을 제공합니다.
 */

export interface ApiSuccessResponse<T> {
  data: T;
}

export interface ApiErrorResponse {
  error: {
    code: string;
    message: string;
    details?: unknown;
  };
}

export type ApiResponse<T> = ApiSuccessResponse<T> | ApiErrorResponse;

/**
 * 타입 가드: 에러 응답인지 확인
 */
export function isApiError(response: unknown): response is ApiErrorResponse {
  return (
    typeof response === 'object' &&
    response !== null &&
    'error' in response &&
    typeof (response as ApiErrorResponse).error?.code === 'string'
  );
}

/**
 * API 에러에서 메시지 추출
 */
export function extractApiErrorMessage(
  error: unknown,
  defaultMessage = '오류가 발생했습니다'
): string {
  if (isApiError(error)) {
    return error.error.message;
  }

  if (error instanceof Error) {
    return error.message;
  }

  return defaultMessage;
}
</file>

<file path="src/lib/supabase/browser-client.ts">
"use client";

import { createBrowserClient } from "@supabase/ssr";
import type { SupabaseClient } from "@supabase/supabase-js";
import { env } from "@/constants/env";
import type { Database } from "./types";

let client: SupabaseClient<Database> | null = null;

export const getSupabaseBrowserClient = () => {
  if (!client) {
    client = createBrowserClient<Database>(
      env.NEXT_PUBLIC_SUPABASE_URL,
      env.NEXT_PUBLIC_SUPABASE_ANON_KEY
    );
  }

  return client;
};
</file>

<file path="src/lib/supabase/client.ts">
import { createBrowserClient } from "@supabase/ssr";

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  );
}
</file>

<file path="src/lib/supabase/server-client.ts">
import { cookies } from "next/headers";
import { createServerClient } from "@supabase/ssr";
import type { SupabaseClient } from "@supabase/supabase-js";
import { env } from "@/constants/env";
import type { Database } from "./types";

type WritableCookieStore = Awaited<ReturnType<typeof cookies>> & {
  set?: (options: {
    name: string;
    value: string;
    path?: string;
    expires?: Date;
    maxAge?: number;
    httpOnly?: boolean;
    sameSite?: "lax" | "strict" | "none";
    secure?: boolean;
  }) => void;
};

export const createSupabaseServerClient = async (): Promise<
  SupabaseClient<Database>
> => {
  const cookieStore = (await cookies()) as WritableCookieStore;

  return createServerClient<Database>(
    env.NEXT_PUBLIC_SUPABASE_URL,
    env.NEXT_PUBLIC_SUPABASE_ANON_KEY,
    {
      cookies: {
        getAll() {
          return cookieStore.getAll();
        },
        setAll(cookiesToSet) {
          cookiesToSet.forEach(({ name, value, options }) => {
            if (typeof cookieStore.set === "function") {
              cookieStore.set({ name, value, ...options });
            }
          });
        },
      },
    }
  );
};
</file>

<file path="src/lib/supabase/server.ts">
import "server-only";

import { createServerClient } from "@supabase/ssr";
import { cookies } from "next/headers";

export async function createClient() {
  const cookieStore = await cookies();

  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!,
    {
      cookies: {
        getAll() {
          return cookieStore.getAll();
        },
        setAll(cookiesToSet) {
          try {
            cookiesToSet.forEach(({ name, value, options }) =>
              cookieStore.set(name, value, options)
            );
          } catch {
            // The `setAll` method was called from a Server Component.
            // This can be ignored if you have middleware refreshing
            // user sessions.
          }
        },
      },
    }
  );
}

export async function createPureClient() {
  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.SUPABASE_SERVICE_ROLE_KEY!,
    {
      cookies: {
        getAll() {
          return [];
        },
        setAll() {},
      },
    }
  );
}
</file>

<file path="src/lib/supabase/types.ts">
export type Database = Record<string, never>;

export type SupabaseUserMetadata = Record<string, unknown>;
</file>

<file path="src/lib/utils/date.ts">
import {
  format,
  parseISO,
  addMonths,
  startOfMonth,
  endOfMonth,
  formatDistanceToNow,
} from 'date-fns';
import { ko } from 'date-fns/locale';

/**
 * 날짜 유틸리티 (date-fns 기반)
 */

/**
 * 날짜 포맷팅
 *
 * @param date 날짜 (Date 또는 ISO 문자열)
 * @param formatStr 포맷 문자열 (기본: 'yyyy-MM-dd')
 * @returns 포맷된 날짜 문자열
 */
export const formatDate = (
  date: Date | string,
  formatStr = 'yyyy-MM-dd'
): string => {
  const d = typeof date === 'string' ? parseISO(date) : date;
  return format(d, formatStr, { locale: ko });
};

/**
 * 상대 날짜 표시
 *
 * @param date 날짜
 * @returns 상대 날짜 문자열 (예: "3일 전", "방금")
 */
export const formatRelativeDate = (date: Date | string): string => {
  const d = typeof date === 'string' ? parseISO(date) : date;
  return formatDistanceToNow(d, { locale: ko, addSuffix: true });
};

/**
 * 구독 시작일 기준 월별 시작/끝 날짜 계산
 *
 * @param startedAt 구독 시작일
 * @param now 현재 날짜 (기본: 현재 시각)
 * @returns 이번 달 시작일과 끝일
 */
export const getSubscriptionPeriod = (
  startedAt: Date,
  now = new Date()
): { start: Date; end: Date } => {
  const monthStart = startOfMonth(now);
  const monthEnd = endOfMonth(now);

  return {
    start: monthStart,
    end: monthEnd,
  };
};

/**
 * 날짜 유효성 검증 (출생일)
 *
 * @param date 날짜
 * @returns 유효하면 true
 */
export const isValidBirthDate = (date: Date): boolean => {
  const now = new Date();
  const minDate = new Date('1900-01-01');
  return date >= minDate && date <= now;
};
</file>

<file path="src/lib/validation/schemas.ts">
import { z } from 'zod';

/**
 * 폼 검증 스키마 (Zod)
 *
 * React Hook Form과 함께 사용됩니다.
 */

/**
 * 생년월일 (과거 날짜만)
 */
export const birthDateSchema = z
  .date()
  .refine((date) => date <= new Date(), '미래 날짜는 선택할 수 없습니다')
  .refine(
    (date) => date >= new Date('1900-01-01'),
    '1900년 이후 날짜를 선택해주세요'
  );

/**
 * 출생 시간 (선택)
 */
export const birthTimeSchema = z
  .string()
  .regex(
    /^([01]\d|2[0-3]):([0-5]\d)$/,
    '올바른 시간 형식이 아닙니다 (HH:MM)'
  )
  .optional();

/**
 * 양력/음력
 */
export const calendarTypeSchema = z.enum(['solar', 'lunar']);

/**
 * 성별
 */
export const genderSchema = z.enum(['male', 'female']);

/**
 * 사주 분석 요청 폼 (프론트엔드용)
 */
export const analysisRequestSchema = z.object({
  birthDate: birthDateSchema.optional(),
  birthTime: birthTimeSchema,
  birthTimeUnknown: z.boolean().default(false),
  isLunar: z.boolean().default(false),
  gender: genderSchema.optional(),
}).superRefine((data, ctx) => {
  // birthDate 필수 검증
  if (!data.birthDate) {
    ctx.addIssue({
      code: z.ZodIssueCode.custom,
      message: '생년월일을 입력해주세요',
      path: ['birthDate'],
    });
  }

  // gender 필수 검증
  if (!data.gender) {
    ctx.addIssue({
      code: z.ZodIssueCode.custom,
      message: '성별을 선택해주세요',
      path: ['gender'],
    });
  }

  // birthTime 검증 (모름 체크하지 않았을 때)
  if (!data.birthTimeUnknown && data.birthTime && !/^([01]\d|2[0-3]):([0-5]\d)$/.test(data.birthTime)) {
    ctx.addIssue({
      code: z.ZodIssueCode.custom,
      message: '올바른 시간 형식이 아닙니다 (HH:MM)',
      path: ['birthTime'],
    });
  }
});

export type AnalysisRequestInput = z.infer<typeof analysisRequestSchema>;
</file>

<file path="src/lib/utils.ts">
import { clsx, type ClassValue } from "clsx";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}
</file>

<file path="src/stores/loading.ts">
import { create } from 'zustand';

/**
 * 전역 로딩 상태 관리 (Zustand)
 */

interface LoadingState {
  isLoading: boolean;
  message?: string;
  startLoading: (message?: string) => void;
  stopLoading: () => void;
}

export const useLoadingStore = create<LoadingState>((set) => ({
  isLoading: false,
  message: undefined,
  startLoading: (message) => set({ isLoading: true, message }),
  stopLoading: () => set({ isLoading: false, message: undefined }),
}));
</file>

<file path="supabase/migrations/0001_create_example_table.sql">
-- Migration: create example table for backend reference implementation
-- Ensures pgcrypto available for gen_random_uuid
create extension if not exists "pgcrypto";

create table if not exists public.example (
  id uuid primary key default gen_random_uuid(),
  full_name text,
  avatar_url text,
  bio text,
  updated_at timestamptz not null default now()
);

comment on table public.example is 'Example table used by the hono + next.js starter backend layer.';

insert into public.example (full_name, avatar_url, bio)
values
  (
    'Jane Example',
    'https://picsum.photos/seed/jane-example/200/200',
    'Demonstration record generated by the starter migration.'
  )
  on conflict do nothing;

ALTER TABLE IF EXISTS public.example DISABLE ROW LEVEL SECURITY;
</file>

<file path="supabase/migrations/0002_create_users_table.sql">
-- Create users table
CREATE TABLE IF NOT EXISTS users (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  clerk_user_id TEXT UNIQUE NOT NULL,
  email TEXT NOT NULL,
  subscription_tier TEXT NOT NULL DEFAULT 'free' CHECK (subscription_tier IN ('free', 'pro')),
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Create indexes
CREATE INDEX IF NOT EXISTS idx_users_clerk_user_id ON users(clerk_user_id);
CREATE INDEX IF NOT EXISTS idx_users_email ON users(email);

-- Disable RLS
ALTER TABLE users DISABLE ROW LEVEL SECURITY;

-- Add comment
COMMENT ON TABLE users IS 'Clerk 인증 시스템과 1:1 매칭되는 사용자 테이블';
</file>

<file path="supabase/migrations/0003_create_subscriptions_table.sql">
-- Create subscriptions table
CREATE TABLE IF NOT EXISTS subscriptions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL,
  plan TEXT NOT NULL DEFAULT 'free' CHECK (plan IN ('free', 'pro')),
  status TEXT NOT NULL DEFAULT 'active' CHECK (status IN ('active', 'canceled', 'expired')),
  billing_key TEXT,
  customer_key TEXT,
  started_at TIMESTAMPTZ,
  next_billing_date TIMESTAMPTZ,
  canceled_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Add foreign key
ALTER TABLE subscriptions
  ADD CONSTRAINT fk_subscriptions_user_id
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE;

-- Create indexes
CREATE INDEX IF NOT EXISTS idx_subscriptions_user_id ON subscriptions(user_id);
CREATE INDEX IF NOT EXISTS idx_subscriptions_status ON subscriptions(status);
CREATE INDEX IF NOT EXISTS idx_subscriptions_next_billing_date
  ON subscriptions(next_billing_date) WHERE status = 'active';

-- Disable RLS
ALTER TABLE subscriptions DISABLE ROW LEVEL SECURITY;

-- Add comment
COMMENT ON TABLE subscriptions IS '구독 정보 및 빌링키 관리';
</file>

<file path="supabase/migrations/0004_create_analyses_table.sql">
-- Create analyses table
CREATE TABLE IF NOT EXISTS analyses (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL,
  birth_date DATE NOT NULL,
  birth_time TIME,
  is_lunar BOOLEAN NOT NULL,
  gender TEXT NOT NULL CHECK (gender IN ('male', 'female')),
  result JSONB NOT NULL,
  model_used TEXT NOT NULL CHECK (model_used IN ('gemini-2.5-flash', 'gemini-2.5-pro')),
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Add foreign key
ALTER TABLE analyses
  ADD CONSTRAINT fk_analyses_user_id
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE;

-- Create indexes
CREATE INDEX IF NOT EXISTS idx_analyses_user_id_created_at
  ON analyses(user_id, created_at DESC);

-- Disable RLS
ALTER TABLE analyses DISABLE ROW LEVEL SECURITY;

-- Add comment
COMMENT ON TABLE analyses IS '사주 분석 결과 영구 보관';
</file>

<file path="supabase/migrations/0005_create_payment_histories_table.sql">
-- Create payment_histories table
CREATE TABLE IF NOT EXISTS payment_histories (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL,
  payment_key TEXT NOT NULL,
  order_id TEXT UNIQUE NOT NULL,
  amount INTEGER NOT NULL CHECK (amount >= 0),
  status TEXT NOT NULL CHECK (status IN ('DONE', 'ABORTED', 'CANCELED')),
  paid_at TIMESTAMPTZ NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Add foreign key
ALTER TABLE payment_histories
  ADD CONSTRAINT fk_payment_histories_user_id
  FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE;

-- Create indexes
CREATE INDEX IF NOT EXISTS idx_payment_histories_user_id ON payment_histories(user_id);
CREATE INDEX IF NOT EXISTS idx_payment_histories_order_id ON payment_histories(order_id);
CREATE INDEX IF NOT EXISTS idx_payment_histories_paid_at ON payment_histories(paid_at DESC);

-- Disable RLS
ALTER TABLE payment_histories DISABLE ROW LEVEL SECURITY;

-- Add comment
COMMENT ON TABLE payment_histories IS '결제 이력 기록';
</file>

<file path="supabase/migrations/0006_add_triggers.sql">
-- Create updated_at trigger function
CREATE OR REPLACE FUNCTION set_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Apply trigger to users table
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_trigger WHERE tgname = 'trigger_users_updated_at'
  ) THEN
    CREATE TRIGGER trigger_users_updated_at
      BEFORE UPDATE ON users
      FOR EACH ROW
      EXECUTE FUNCTION set_updated_at();
  END IF;
END $$;

-- Apply trigger to subscriptions table
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_trigger WHERE tgname = 'trigger_subscriptions_updated_at'
  ) THEN
    CREATE TRIGGER trigger_subscriptions_updated_at
      BEFORE UPDATE ON subscriptions
      FOR EACH ROW
      EXECUTE FUNCTION set_updated_at();
  END IF;
END $$;

-- Add comments
COMMENT ON FUNCTION set_updated_at() IS 'updated_at 필드를 자동으로 현재 시각으로 업데이트';
</file>

<file path=".cursorignore">
pnpm-lock.yaml
yarn.lock
package-lock.json
</file>

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*

# vercel
.vercel

# EasyNext
.easynext

# typescript
*.tsbuildinfo
next-env.d.ts


# START Ruler Generated Files
/.cursor/rules/ruler_cursor_instructions.mdc
/.cursor/rules/ruler_cursor_instructions.mdc.bak
/CLAUDE.md
/CLAUDE.md.bak
# END Ruler Generated Files
</file>

<file path=".vercel-redeploy">
# Force Vercel redeploy - #오후
</file>

<file path="components.json">
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "default",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "",
    "css": "src/app/globals.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  }
}
</file>

<file path="eslint.config.mjs">
import { dirname } from 'path';
import { fileURLToPath } from 'url';
import { FlatCompat } from '@eslint/eslintrc';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const compat = new FlatCompat({
  baseDirectory: __dirname,
});

const eslintConfig = [
  ...compat.extends('next/core-web-vitals', 'next/typescript'),
  {
    rules: {
      '@typescript-eslint/no-empty-object-type': 'off',
      '@typescript-eslint/no-explicit-any': 'off',
      '@typescript-eslint/no-unused-vars': 'off',
    },
  },
];

export default eslintConfig;
</file>

<file path="next.config.ts">
import type { NextConfig } from 'next';

const nextConfig: NextConfig = {
  /* config options here */
  eslint: {
    ignoreDuringBuilds: true,
  },
  images: {
    remotePatterns: [
      {
        hostname: '**',
      },
    ],
  },
};

export default nextConfig;
</file>

<file path="tailwind.config.ts">
import type { Config } from "tailwindcss";

const config: Config = {
  darkMode: ["class"],
  content: [
    "./src/pages/**/*.{js,ts,jsx,tsx,mdx}",
    "./src/components/**/*.{js,ts,jsx,tsx,mdx}",
    "./src/features/**/*.{js,ts,jsx,tsx,mdx}",
    "./src/app/**/*.{js,ts,jsx,tsx,mdx}",
  ],
  theme: {
    extend: {
      colors: {
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
      },
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
      keyframes: {
        "accordion-down": {
          from: { height: "0" },
          to: { height: "var(--radix-accordion-content-height)" },
        },
        "accordion-up": {
          from: { height: "var(--radix-accordion-content-height)" },
          to: { height: "0" },
        },
      },
      animation: {
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
      },
    },
  },
  plugins: [require("tailwindcss-animate"), require("@tailwindcss/typography")],
};

export default config;
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "strictNullChecks": false,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noImplicitAny": false,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
</file>

<file path="src/app/(protected)/dashboard/page.tsx">
'use client';

import { DashboardProvider, useDashboard } from '@/features/dashboard/context/dashboard-context';
import {
  useCurrentUser,
  useUsageInfo,
  useAnalysisHistory,
} from '@/features/dashboard/hooks/use-dashboard-data';
import { DashboardHeader } from '@/features/dashboard/components/dashboard-header';
import { AnalysisCard } from '@/features/dashboard/components/analysis-card';
import { Button } from '@/components/ui/button';
import { useRouter } from 'next/navigation';
import { APP_CONFIG } from '@/constants/app';

function DashboardContent() {
  const router = useRouter();
  const { state } = useDashboard();
  const { data: currentUser, isLoading: isLoadingUser } = useCurrentUser();
  const { data: usageInfo, isLoading: isLoadingUsage } = useUsageInfo();
  const { data: analysisHistory, isLoading: isLoadingHistory } = useAnalysisHistory(
    state.currentPage,
    state.pageSize
  );

  if (isLoadingUser || isLoadingUsage) {
    return <div className="container mx-auto py-8">로딩 중...</div>;
  }

  if (!currentUser || !usageInfo) {
    return <div className="container mx-auto py-8">사용자 정보를 불러올 수 없습니다.</div>;
  }

  const canAnalyze = usageInfo.remaining > 0;

  return (
    <div className="container mx-auto py-8 space-y-8">
      <DashboardHeader user={currentUser} usage={usageInfo} />

      <div className="flex flex-col sm:flex-row gap-4">
        <Button
          size="lg"
          onClick={() => router.push(APP_CONFIG.routes.analysisNew)}
          disabled={!canAnalyze}
        >
          새 분석하기
        </Button>

        {currentUser.subscriptionTier === 'free' && (
          <Button
            size="lg"
            variant="outline"
            onClick={() => router.push(APP_CONFIG.routes.subscription)}
          >
            Pro로 업그레이드
          </Button>
        )}
      </div>

      {!canAnalyze && (
        <p className="text-sm text-muted-foreground">
          {currentUser.subscriptionTier === 'free'
            ? '무료 체험을 모두 사용하셨습니다. Pro로 업그레이드하여 더 많은 분석을 받아보세요.'
            : '이번 달 분석 횟수를 모두 사용하셨습니다.'}
        </p>
      )}

      <div className="space-y-4">
        <h2 className="text-xl font-bold">분석 이력</h2>

        {isLoadingHistory ? (
          <div>이력 로딩 중...</div>
        ) : analysisHistory && analysisHistory.data.length > 0 ? (
          <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-3">
            {analysisHistory.data.map((analysis) => (
              <AnalysisCard key={analysis.id} analysis={analysis} />
            ))}
          </div>
        ) : (
          <div className="flex flex-col items-center justify-center py-12 space-y-4">
            <div className="text-center space-y-2">
              <h3 className="text-lg font-semibold">아직 분석 이력이 없습니다</h3>
              <p className="text-sm text-muted-foreground">
                첫 번째 사주 분석을 시작해보세요!
              </p>
            </div>
            <Button onClick={() => router.push(APP_CONFIG.routes.analysisNew)}>
              새 분석하기
            </Button>
          </div>
        )}
      </div>
    </div>
  );
}

export default function DashboardPage() {
  return (
    <DashboardProvider>
      <DashboardContent />
    </DashboardProvider>
  );
}
</file>

<file path="src/app/(protected)/layout.tsx">
import { type ReactNode } from "react";

type ProtectedLayoutProps = {
  children: ReactNode;
};

export default function ProtectedLayout({ children }: ProtectedLayoutProps) {
  return <>{children}</>;
}
</file>

<file path="src/app/globals.css">
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 0 0% 3.9%;
    --card: 0 0% 100%;
    --card-foreground: 0 0% 3.9%;
    --popover: 0 0% 100%;
    --popover-foreground: 0 0% 3.9%;
    --primary: 0 0% 9%;
    --primary-foreground: 0 0% 98%;
    --secondary: 0 0% 96.1%;
    --secondary-foreground: 0 0% 9%;
    --muted: 0 0% 96.1%;
    --muted-foreground: 0 0% 45.1%;
    --accent: 0 0% 96.1%;
    --accent-foreground: 0 0% 9%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 0 0% 98%;
    --border: 0 0% 89.8%;
    --input: 0 0% 89.8%;
    --ring: 0 0% 3.9%;
    --radius: 0.5rem;
    --chart-1: 12 76% 61%;
    --chart-2: 173 58% 39%;
    --chart-3: 197 37% 24%;
    --chart-4: 43 74% 66%;
    --chart-5: 27 87% 67%;
  }

  .dark {
    --background: 0 0% 3.9%;
    --foreground: 0 0% 98%;
    --card: 0 0% 3.9%;
    --card-foreground: 0 0% 98%;
    --popover: 0 0% 3.9%;
    --popover-foreground: 0 0% 98%;
    --primary: 0 0% 98%;
    --primary-foreground: 0 0% 9%;
    --secondary: 0 0% 14.9%;
    --secondary-foreground: 0 0% 98%;
    --muted: 0 0% 14.9%;
    --muted-foreground: 0 0% 63.9%;
    --accent: 0 0% 14.9%;
    --accent-foreground: 0 0% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 0 0% 98%;
    --border: 0 0% 14.9%;
    --input: 0 0% 14.9%;
    --ring: 0 0% 83.1%;
    --chart-1: 220 70% 50%;
    --chart-2: 160 60% 45%;
    --chart-3: 30 80% 55%;
    --chart-4: 280 65% 60%;
    --chart-5: 340 75% 55%;
  }
}

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}
</file>

<file path="src/app/page.tsx">
'use client';

import { useUser } from '@clerk/nextjs';
import { Header } from '@/features/landing/components/header';
import { HeroSection } from '@/features/landing/components/hero-section';
import { FeaturesSection } from '@/features/landing/components/features-section';
import { PricingSection } from '@/features/landing/components/pricing-section';
import { CTASection } from '@/features/landing/components/cta-section';
import { Footer } from '@/features/landing/components/footer';

export default function LandingPage() {
  const { isSignedIn, isLoaded } = useUser();

  // 로딩 중 처리
  if (!isLoaded) {
    return (
      <div className="flex min-h-screen items-center justify-center">
        <div className="h-8 w-8 animate-spin rounded-full border-4 border-primary border-t-transparent"></div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-background">
      <Header isSignedIn={!!isSignedIn} />
      <main>
        <HeroSection isSignedIn={!!isSignedIn} />
        <FeaturesSection />
        <PricingSection />
        <CTASection isSignedIn={!!isSignedIn} />
      </main>
      <Footer />
    </div>
  );
}
</file>

<file path="src/app/providers.tsx">
"use client";

import {
  isServer,
  QueryClient,
  QueryClientProvider,
} from "@tanstack/react-query";
import { ThemeProvider } from "next-themes";
import { ClerkProvider } from "@clerk/nextjs";

function makeQueryClient() {
  return new QueryClient({
    defaultOptions: {
      queries: {
        // With SSR, we usually want to set some default staleTime
        // above 0 to avoid refetching immediately on the client
        staleTime: 60 * 1000,
      },
    },
  });
}

let browserQueryClient: QueryClient | undefined = undefined;

function getQueryClient() {
  if (isServer) {
    // Server: always make a new query client
    return makeQueryClient();
  } else {
    // Browser: make a new query client if we don't already have one
    // This is very important, so we don't re-make a new client if React
    // suspends during the initial render. This may not be needed if we
    // have a suspense boundary BELOW the creation of the query client
    if (!browserQueryClient) browserQueryClient = makeQueryClient();
    return browserQueryClient;
  }
}

export default function Providers({ children }: { children: React.ReactNode }) {
  // NOTE: Avoid useState when initializing the query client if you don't
  //       have a suspense boundary between this and the code that may
  //       suspend because React will throw away the client on the initial
  //       render if it suspends and there is no boundary
  const queryClient = getQueryClient();

  return (
    <ClerkProvider>
      <ThemeProvider
        attribute="class"
        defaultTheme="system"
        enableSystem
        forcedTheme="light"
        disableTransitionOnChange
      >
        <QueryClientProvider client={queryClient}>
          {children}
        </QueryClientProvider>
      </ThemeProvider>
    </ClerkProvider>
  );
}
</file>

<file path="src/backend/hono/app.ts">
import { Hono } from 'hono';
import { errorBoundary } from '@/backend/middleware/error';
import { withAppContext } from '@/backend/middleware/context';
import { withSupabase } from '@/backend/middleware/supabase';
import { registerExampleRoutes } from '@/features/example/backend/route';
import { authRouter } from '@/features/auth/backend/route';
import { dashboardRouter } from '@/features/dashboard/backend/route';
import { analysisRouter } from '@/features/analysis/backend/route';
import { registerSubscriptionRoutes } from '@/features/subscription/backend/route';
import { registerWebhookRoutes } from '@/features/subscription/backend/webhook';
import { registerBillingCallbackRoutes } from '@/features/subscription/backend/billing-callback';
import type { AppEnv } from '@/backend/hono/context';

let singletonApp: Hono<AppEnv> | null = null;

export const createHonoApp = () => {
  if (singletonApp) {
    return singletonApp;
  }

  const app = new Hono<AppEnv>();

  app.use('*', errorBoundary());
  app.use('*', withAppContext());
  app.use('*', withSupabase());

  registerExampleRoutes(app);

  // 대시보드 관련 라우터 등록
  app.route('/api', authRouter);
  app.route('/api', dashboardRouter);
  app.route('/api', analysisRouter);

  // 구독 관련 라우터 등록
  registerSubscriptionRoutes(app);
  registerWebhookRoutes(app);
  registerBillingCallbackRoutes(app);

  singletonApp = app;

  return app;
};
</file>

<file path="src/backend/hono/context.ts">
import type { Context } from 'hono';
import type { SupabaseClient } from '@supabase/supabase-js';

export type AppLogger = Pick<Console, 'info' | 'error' | 'warn' | 'debug'>;

export type AppConfig = {
  supabase: {
    url: string;
    serviceRoleKey: string;
  };
  clerk: {
    secretKey: string;
    publishableKey: string;
    webhookSigningSecret: string;
  };
  gemini: {
    apiKey: string;
  };
  toss: {
    secretKey: string;
    clientKey: string;
    webhookSecret: string;
  };
};

export type AppVariables = {
  supabase: SupabaseClient;
  logger: AppLogger;
  config: AppConfig;
  clerkUserId?: string;
  userId?: string;
};

export type AppEnv = {
  Variables: AppVariables;
};

export type AppContext = Context<AppEnv>;

export const contextKeys = {
  supabase: 'supabase',
  logger: 'logger',
  config: 'config',
  clerkUserId: 'clerkUserId',
  userId: 'userId',
} as const satisfies Record<keyof AppVariables, keyof AppVariables>;

export const getSupabase = (c: AppContext) =>
  c.get(contextKeys.supabase) as SupabaseClient;

export const getLogger = (c: AppContext) =>
  c.get(contextKeys.logger) as AppLogger;

export const getConfig = (c: AppContext) =>
  c.get(contextKeys.config) as AppConfig;
</file>

<file path="src/backend/http/response.ts">
import type { ContentfulStatusCode } from 'hono/utils/http-status';
import type { AppContext } from '@/backend/hono/context';

export type SuccessResult<TData> = {
  ok: true;
  status: ContentfulStatusCode;
  data: TData;
};

export type ErrorResult<TCode extends string, TDetails = unknown> = {
  ok: false;
  status: ContentfulStatusCode;
  error: {
    code: TCode;
    message: string;
    details?: TDetails;
  };
};

export type HandlerResult<TData, TCode extends string, TDetails = unknown> =
  | SuccessResult<TData>
  | ErrorResult<TCode, TDetails>;

export const success = <TData>(
  data: TData,
  status: ContentfulStatusCode = 200,
): SuccessResult<TData> => ({
  ok: true,
  status,
  data,
});

export const failure = <TCode extends string, TDetails = unknown>(
  status: ContentfulStatusCode,
  code: TCode,
  message: string,
  details?: TDetails,
): ErrorResult<TCode, TDetails> => ({
  ok: false,
  status,
  error: {
    code,
    message,
    ...(details === undefined ? {} : { details }),
  },
});

export const respond = <TData, TCode extends string, TDetails = unknown>(
  c: AppContext,
  result: HandlerResult<TData, TCode, TDetails>,
) => {
  if (result.ok) {
    return c.json(
      {
        data: result.data,
      },
      result.status,
    );
  }

  const errorResult = result as ErrorResult<TCode, TDetails>;

  return c.json(
    {
      error: errorResult.error,
    },
    errorResult.status,
  );
};
</file>

<file path="src/backend/middleware/auth.ts">
import type { MiddlewareHandler } from 'hono';
import { verifyToken } from '@clerk/backend';
import type { AppEnv } from '@/backend/hono/context';
import { CommonErrorCode } from '@/backend/errors/codes';
import { failure } from '@/backend/http/response';

/**
 * Clerk 인증 미들웨어
 *
 * Authorization 헤더에서 Bearer 토큰을 추출하고 검증합니다.
 * 검증 성공 시 clerkUserId와 userId(DB UUID)를 컨텍스트에 주입합니다.
 */

/**
 * 필수 인증 미들웨어
 *
 * 인증되지 않은 경우 401 에러를 반환합니다.
 *
 * @example
 * ```ts
 * app.get('/api/protected', requireAuth(), async (c) => {
 *   const userId = c.get('userId'); // 자동 주입됨
 *   // ...
 * });
 * ```
 */
export const requireAuth = (): MiddlewareHandler<AppEnv> => {
  return async (c, next) => {
    const logger = c.get('logger');
    const supabase = c.get('supabase');
    const config = c.get('config');

    // Authorization 헤더에서 토큰 추출
    const authHeader = c.req.header('Authorization');
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      logger.warn('Missing or invalid Authorization header');
      return c.json(
        failure(401, CommonErrorCode.UNAUTHORIZED, '로그인이 필요합니다'),
        401
      );
    }

    const token = authHeader.substring(7);

    try {
      // Clerk 토큰 검증
      const payload = await verifyToken(token, {
        secretKey: config.clerk.secretKey,
      });

      const clerkUserId = payload.sub;

      if (!clerkUserId) {
        logger.warn('Invalid token: missing sub claim');
        return c.json(
          failure(401, CommonErrorCode.UNAUTHORIZED, '유효하지 않은 토큰입니다'),
          401
        );
      }

      // DB에서 사용자 조회
      let { data: user, error } = await supabase
        .from('users')
        .select('id, email')
        .eq('clerk_user_id', clerkUserId)
        .single();

      // 사용자가 없으면 자동 생성 (Clerk에서 이메일 가져오기)
      if (error || !user) {
        logger.info('User not found, creating new user', { clerkUserId });

        try {
          // Clerk API를 통해 사용자 정보 가져오기
          const clerkUser = await fetch(`https://api.clerk.com/v1/users/${clerkUserId}`, {
            headers: {
              Authorization: `Bearer ${config.clerk.secretKey}`,
            },
          }).then(res => res.json());

          const email = clerkUser.email_addresses?.[0]?.email_address || `${clerkUserId}@clerk.user`;

          // 새 사용자 생성
          const { data: newUser, error: createError } = await supabase
            .from('users')
            .insert({
              clerk_user_id: clerkUserId,
              email,
              subscription_tier: 'free',
            })
            .select('id, email')
            .single();

          if (createError || !newUser) {
            logger.error('Failed to create user', { clerkUserId, createError });
            return c.json(
              failure(500, CommonErrorCode.INTERNAL_ERROR, '사용자 생성에 실패했습니다'),
              500
            );
          }

          user = newUser;
          logger.info('User created successfully', { clerkUserId, userId: user.id });
        } catch (createError) {
          logger.error('Failed to create user', { clerkUserId, createError });
          return c.json(
            failure(500, CommonErrorCode.INTERNAL_ERROR, '사용자 생성에 실패했습니다'),
            500
          );
        }
      }

      // 컨텍스트에 사용자 정보 주입
      c.set('clerkUserId', clerkUserId);
      c.set('userId', user.id);

      await next();
    } catch (error) {
      logger.error('Authentication failed', error);
      return c.json(
        failure(
          401,
          CommonErrorCode.SESSION_EXPIRED,
          '세션이 만료되었습니다. 다시 로그인해주세요'
        ),
        401
      );
    }
  };
};

/**
 * 선택적 인증 미들웨어
 *
 * 토큰이 있으면 검증하고, 없어도 요청을 통과시킵니다.
 * 공개 엔드포인트에서 사용자 정보가 있을 때만 추가 기능을 제공하는 경우 유용합니다.
 *
 * @example
 * ```ts
 * app.get('/api/public', optionalAuth(), async (c) => {
 *   const userId = c.get('userId'); // 있을 수도, 없을 수도 있음
 *   if (userId) {
 *     // 인증된 사용자 로직
 *   } else {
 *     // 비인증 사용자 로직
 *   }
 * });
 * ```
 */
export const optionalAuth = (): MiddlewareHandler<AppEnv> => {
  return async (c, next) => {
    const logger = c.get('logger');
    const supabase = c.get('supabase');
    const config = c.get('config');

    const authHeader = c.req.header('Authorization');

    // 토큰이 없으면 그냥 통과
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      await next();
      return;
    }

    const token = authHeader.substring(7);

    try {
      // Clerk 토큰 검증
      const payload = await verifyToken(token, {
        secretKey: config.clerk.secretKey,
      });

      const clerkUserId = payload.sub;

      if (clerkUserId) {
        const { data: user } = await supabase
          .from('users')
          .select('id')
          .eq('clerk_user_id', clerkUserId)
          .single();

        if (user) {
          c.set('clerkUserId', clerkUserId);
          c.set('userId', user.id);
        }
      }

      await next();
    } catch (error) {
      logger.warn('Optional auth failed, continuing as unauthenticated', error);
      await next();
    }
  };
};
</file>

<file path="src/backend/middleware/context.ts">
import { createMiddleware } from 'hono/factory';
import { getAppConfig } from '@/backend/config';
import {
  contextKeys,
  type AppEnv,
  type AppLogger,
} from '@/backend/hono/context';

const logger: AppLogger = {
  info: (...args) => console.info(...args),
  error: (...args) => console.error(...args),
  warn: (...args) => console.warn(...args),
  debug: (...args) => console.debug(...args),
};

export const withAppContext = () => {
  return createMiddleware<AppEnv>(async (c, next) => {
    // 런타임에만 config를 가져옴 (빌드 타임이 아닌)
    const config = getAppConfig();

    c.set(contextKeys.logger, logger);
    c.set(contextKeys.config, config);

    await next();
  });
};
</file>

<file path="src/constants/auth.ts">
import { match } from "ts-pattern";

const PUBLIC_PATHS = ["/", "/sign-in", "/sign-up"] as const;
const PUBLIC_PREFIXES = ["/_next", "/api", "/favicon", "/static", "/docs", "/images"] as const;

export const LOGIN_PATH = "/sign-in";
export const SIGNUP_PATH = "/sign-up";
export const AUTH_ENTRY_PATHS = [LOGIN_PATH, SIGNUP_PATH] as const;
export const isAuthEntryPath = (
  pathname: string
): pathname is (typeof AUTH_ENTRY_PATHS)[number] =>
  AUTH_ENTRY_PATHS.includes(pathname as (typeof AUTH_ENTRY_PATHS)[number]);

export const isAuthPublicPath = (pathname: string) => {
  const normalized = pathname.toLowerCase();

  return match(normalized)
    .when(
      (path) => PUBLIC_PATHS.some((publicPath) => publicPath === path),
      () => true
    )
    .when(
      (path) => PUBLIC_PREFIXES.some((prefix) => path.startsWith(prefix)),
      () => true
    )
    .otherwise(() => false);
};

export const shouldProtectPath = (pathname: string) => !isAuthPublicPath(pathname);
</file>

<file path="src/constants/env.ts">
import { z } from 'zod';

const clientEnvSchema = z.object({
  NEXT_PUBLIC_SUPABASE_URL: z.string().url(),
  NEXT_PUBLIC_SUPABASE_ANON_KEY: z.string().min(1),
});

// 빌드 타임에는 환경 변수 검증을 건너뜀
const isBuildTime = process.env.NEXT_PHASE === 'phase-production-build';

const _clientEnv = isBuildTime
  ? {
      success: true as const,
      data: {
        NEXT_PUBLIC_SUPABASE_URL: '',
        NEXT_PUBLIC_SUPABASE_ANON_KEY: '',
      },
    }
  : clientEnvSchema.safeParse({
      NEXT_PUBLIC_SUPABASE_URL: process.env.NEXT_PUBLIC_SUPABASE_URL,
      NEXT_PUBLIC_SUPABASE_ANON_KEY: process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY,
    });

export type ClientEnv = z.infer<typeof clientEnvSchema>;

if (!_clientEnv.success) {
  console.error('환경 변수 검증 실패:', _clientEnv.error.flatten().fieldErrors);
  throw new Error('환경 변수를 확인하세요.');
}

export const env: ClientEnv = _clientEnv.data;
</file>

<file path="src/features/analysis/backend/route.ts">
import { Hono } from 'hono';
import { zValidator } from '@hono/zod-validator';
import { z } from 'zod';
import { requireAuth } from '@/backend/middleware/auth';
import { respond, success, failure } from '@/backend/http/response';
import { getAnalysisHistory, getAnalysisById, createAnalysis, getAnalysisDetail } from './service';
import { createAnalysisRequestSchema, AnalysisIdParamsSchema } from './schema';
import { checkUsageLimit } from '@/backend/services/usage';
import { CommonErrorCode } from '@/backend/errors/codes';
import type { AppEnv } from '@/backend/hono/context';
import { getLogger, getSupabase } from '@/backend/hono/context';

export const analysisRouter = new Hono<AppEnv>();

export function registerAnalysisRoutes(app: Hono<AppEnv>) {
  app.route('/api', analysisRouter);
}

/**
 * 쿼리 파라미터 스키마
 */
const querySchema = z.object({
  page: z
    .string()
    .transform(Number)
    .pipe(z.number().int().min(1))
    .default('1'),
  limit: z
    .string()
    .transform(Number)
    .pipe(z.number().int().min(1).max(20))
    .default('10'),
});

/**
 * GET /api/analyses
 *
 * 분석 이력 목록 조회 (페이지네이션)
 */
analysisRouter.get('/analyses', requireAuth(), zValidator('query', querySchema), async (c) => {
  try {
    const userId = c.get('userId');
    const supabase = c.get('supabase');

    if (!userId) {
      return respond(
        c,
        failure(401, CommonErrorCode.UNAUTHORIZED, '로그인이 필요합니다')
      );
    }

    const { page, limit } = c.req.valid('query');

    const history = await getAnalysisHistory(supabase, userId, page, limit);

    return respond(c, success(history));
  } catch (error) {
    const logger = c.get('logger');
    logger.error('Failed to get analysis history', error);

    return respond(
      c,
      failure(500, CommonErrorCode.INTERNAL_ERROR, '분석 이력을 불러올 수 없습니다')
    );
  }
});

/**
 * GET /api/analyses/usage
 *
 * 사용자의 분석 사용량 조회
 */
analysisRouter.get('/analyses/usage', requireAuth(), async (c) => {
  const userId = c.get('userId');
  if (!userId) {
    return respond(
      c,
      failure(401, CommonErrorCode.UNAUTHORIZED, '인증이 필요합니다')
    );
  }

  const supabase = c.get('supabase');
  const logger = c.get('logger');

  try {
    const usageInfo = await checkUsageLimit(supabase, userId);

    // 구독 티어 조회
    const { data: user } = await supabase
      .from('users')
      .select('subscription_tier')
      .eq('id', userId)
      .single();

    const subscriptionTier = (user?.subscription_tier as 'free' | 'pro') || 'free';

    return respond(c, success({
      subscriptionTier,
      used: usageInfo.used,
      limit: usageInfo.limit,
      remaining: usageInfo.remaining,
      nextResetDate: usageInfo.nextResetDate?.toISOString(),
    }));
  } catch (error) {
    logger.error('Failed to fetch usage', error);
    return respond(
      c,
      failure(500, CommonErrorCode.INTERNAL_ERROR, '사용량 조회 중 오류가 발생했습니다')
    );
  }
});

/**
 * GET /api/analyses/:id
 *
 * 특정 분석 상세 조회 (상세보기 페이지)
 */
analysisRouter.get('/analyses/:id', requireAuth(), async (c) => {
  const logger = getLogger(c);
  const supabase = getSupabase(c);
  const userId = c.get('userId');

  // 1. 파라미터 검증
  const parsedParams = AnalysisIdParamsSchema.safeParse({
    id: c.req.param('id'),
  });

  if (!parsedParams.success) {
    return respond(
      c,
      failure(
        400,
        'INVALID_PARAMS',
        '유효하지 않은 분석 ID입니다',
        parsedParams.error.format()
      )
    );
  }

  // 2. 서비스 호출
  const result = await getAnalysisDetail(
    supabase,
    parsedParams.data.id,
    userId!
  );

  // 3. 에러 로깅 (500번대 에러만)
  if (!result.ok && result.status >= 500) {
    logger.error('Failed to fetch analysis', {
      analysisId: parsedParams.data.id,
      userId,
      error: 'error' in result ? result.error : undefined,
    });
  }

  // 4. 응답 반환
  return respond(c, result);
});

/**
 * POST /api/analyses
 *
 * 새로운 사주 분석 생성
 */
analysisRouter.post(
  '/analyses',
  requireAuth(),
  zValidator('json', createAnalysisRequestSchema),
  async (c) => {
    const userId = c.get('userId');
    if (!userId) {
      return respond(
        c,
        failure(401, CommonErrorCode.UNAUTHORIZED, '인증이 필요합니다')
      );
    }

    const body = c.req.valid('json');
    const supabase = c.get('supabase');
    const logger = c.get('logger');
    const config = c.get('config');

    const result = await createAnalysis(
      supabase,
      userId,
      body,
      logger,
      config.gemini.apiKey
    );

    return respond(c, result);
  }
);
</file>

<file path="src/features/analysis/lib/error.ts">
'use client';

import { isAxiosError } from 'axios';

export type AnalysisErrorType =
  | 'forbidden'
  | 'not-found'
  | 'network'
  | 'unknown';

export function getAnalysisErrorType(error: unknown): AnalysisErrorType {
  if (!error) return 'unknown';

  // Axios error handling
  if (isAxiosError(error)) {
    const code = (error.response?.data as any)?.error?.code;

    if (code === 'ANALYSIS_FORBIDDEN') {
      return 'forbidden';
    }

    if (code === 'ANALYSIS_NOT_FOUND') {
      return 'not-found';
    }

    // Network error
    if (!error.response) {
      return 'network';
    }
  }

  // Other network errors
  if (error instanceof Error && error.message.includes('Network')) {
    return 'network';
  }

  return 'unknown';
}
</file>

<file path="src/features/dashboard/hooks/use-dashboard-data.ts">
import { useQuery, useQueryClient } from '@tanstack/react-query';
import { useAuth } from '@clerk/nextjs';
import { apiClient } from '@/lib/remote/api-client';
import type { CurrentUserResponse } from '@/features/auth/lib/dto';
import type { UsageInfoResponse } from '@/features/dashboard/lib/dto';
import type { AnalysisHistoryResponse } from '@/features/analysis/lib/dto';

export function useCurrentUser() {
  const { getToken } = useAuth();

  return useQuery({
    queryKey: ['currentUser'],
    queryFn: async () => {
      const token = await getToken();
      const response = await apiClient.get<{ data: CurrentUserResponse }>('/api/me', {
        headers: {
          Authorization: token ? `Bearer ${token}` : undefined,
        },
      });
      return response.data.data;
    },
    staleTime: 5 * 60 * 1000,
    refetchOnMount: true,
    refetchOnWindowFocus: false,
  });
}

export function useUsageInfo() {
  const { getToken } = useAuth();

  return useQuery({
    queryKey: ['usageInfo'],
    queryFn: async () => {
      const token = await getToken();
      const response = await apiClient.get<{ data: UsageInfoResponse }>('/api/me/usage', {
        headers: {
          Authorization: token ? `Bearer ${token}` : undefined,
        },
      });
      return response.data.data;
    },
    staleTime: 1 * 60 * 1000,
    refetchOnMount: true,
    refetchOnWindowFocus: false,
  });
}

export function useAnalysisHistory(page: number, limit: number) {
  const { getToken } = useAuth();

  return useQuery({
    queryKey: ['analyses', { page, limit }],
    queryFn: async () => {
      const token = await getToken();
      const response = await apiClient.get<{ data: AnalysisHistoryResponse }>(
        `/api/analyses?page=${page}&limit=${limit}`,
        {
          headers: {
            Authorization: token ? `Bearer ${token}` : undefined,
          },
        }
      );
      return response.data.data;
    },
    staleTime: 5 * 60 * 1000,
    refetchOnWindowFocus: false,
  });
}

export function useInvalidateDashboard() {
  const queryClient = useQueryClient();

  return {
    invalidateAll: () => {
      queryClient.invalidateQueries({ queryKey: ['usageInfo'] });
      queryClient.invalidateQueries({ queryKey: ['analyses'] });
    },
    invalidateUser: () => {
      queryClient.invalidateQueries({ queryKey: ['currentUser'] });
      queryClient.invalidateQueries({ queryKey: ['usageInfo'] });
    },
    invalidatePage: (page: number) => {
      queryClient.invalidateQueries({ queryKey: ['analyses', { page }] });
    },
  };
}
</file>

<file path="src/features/subscription/backend/route.ts">
import type { Hono } from 'hono';
import { zValidator } from '@hono/zod-validator';
import type { AppEnv } from '@/backend/hono/context';
import { requireAuth } from '@/backend/middleware/auth';
import { failure, respond, success } from '@/backend/http/response';
import {
  subscribeRequestSchema,
  cancelRequestSchema,
  resumeRequestSchema,
} from './schema';
import {
  getSubscription,
  getUsageInfo,
  getPaymentHistories,
  createProSubscription,
  cancelSubscription,
  resumeSubscription,
} from './service';
import { subscriptionErrorCodes } from './error';

export const registerSubscriptionRoutes = (app: Hono<AppEnv>) => {
  app.get('/api/subscription', requireAuth(), async (c) => {
    const userId = c.get('userId')!;
    const supabase = c.get('supabase');

    const subscription = await getSubscription(supabase, userId);

    return respond(c, success(subscription));
  });

  app.get('/api/usage', requireAuth(), async (c) => {
    const userId = c.get('userId')!;
    const supabase = c.get('supabase');

    try {
      const usageInfo = await getUsageInfo(supabase, userId);
      return respond(c, success(usageInfo));
    } catch (error: any) {
      return respond(c, failure(500, 'USAGE_FETCH_ERROR', error.message));
    }
  });

  app.get('/api/payment-histories', requireAuth(), async (c) => {
    const userId = c.get('userId')!;
    const supabase = c.get('supabase');

    const page = parseInt(c.req.query('page') ?? '1', 10);
    const limit = parseInt(c.req.query('limit') ?? '10', 10);

    const histories = await getPaymentHistories(supabase, userId, page, limit);

    return respond(c, success(histories));
  });

  app.post(
    '/api/subscription/subscribe',
    requireAuth(),
    zValidator('json', subscribeRequestSchema),
    async (c) => {
      const userId = c.get('userId')!;
      const supabase = c.get('supabase');
      const config = c.get('config');
      const { authKey } = c.req.valid('json');

      try {
        await createProSubscription(
          supabase,
          userId,
          authKey,
          config.toss.secretKey
        );
        return respond(c, success({ message: 'Pro 구독이 시작되었습니다' }));
      } catch (error: any) {
        if (error.code === subscriptionErrorCodes.subscriptionAlreadyActive) {
          return respond(c, failure(400, error.code, error.message));
        }
        return respond(
          c,
          failure(
            500,
            subscriptionErrorCodes.billingKeyIssueFailed,
            error.message
          )
        );
      }
    }
  );

  app.post(
    '/api/subscription/cancel',
    requireAuth(),
    zValidator('json', cancelRequestSchema),
    async (c) => {
      const userId = c.get('userId')!;
      const supabase = c.get('supabase');
      const { reason } = c.req.valid('json');

      try {
        const result = await cancelSubscription(supabase, userId, reason);
        return respond(c, success({
          status: 'canceled',
          nextBillingDate: result.nextBillingDate,
          message: '구독이 취소되었습니다',
        }));
      } catch (error: any) {
        if (error.code === subscriptionErrorCodes.subscriptionNotActive) {
          return respond(c, failure(400, error.code, error.message));
        }
        return respond(
          c,
          failure(500, 'CANCEL_SUBSCRIPTION_ERROR', error.message)
        );
      }
    }
  );

  app.post('/api/subscription/resume', requireAuth(), async (c) => {
    const userId = c.get('userId')!;
    const supabase = c.get('supabase');

    try {
      const result = await resumeSubscription(supabase, userId);
      return respond(c, success({
        status: 'active',
        nextBillingDate: result.nextBillingDate,
        message: '구독이 재개되었습니다',
      }));
    } catch (error: any) {
      if (error.code === subscriptionErrorCodes.subscriptionExpired) {
        return respond(c, failure(400, error.code, error.message));
      }
      return respond(
        c,
        failure(500, 'RESUME_SUBSCRIPTION_ERROR', error.message)
      );
    }
  });
};
</file>

<file path="src/features/subscription/context/subscription-context.tsx">
'use client';

import React, { createContext, useContext, useReducer, useMemo, useCallback } from 'react';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { differenceInDays } from 'date-fns';
import { apiClient, extractApiErrorMessage } from '@/lib/remote/api-client';
import { APP_CONFIG } from '@/constants/app';
import { useToast } from '@/hooks/use-toast';
import { useUser, useAuth } from '@clerk/nextjs';
import type { Subscription, UsageInfo, PaymentHistory } from '../backend/schema';

interface SubscriptionPageState {
  paymentFlow: 'idle' | 'processing' | 'success' | 'error';
  paymentError: string | null;
  cancelModalOpen: boolean;
  resumeModalOpen: boolean;
  selectedReason: string | null;
}

type SubscriptionPageAction =
  | { type: 'PAYMENT_START' }
  | { type: 'PAYMENT_SUCCESS' }
  | { type: 'PAYMENT_ERROR'; payload: { error: string } }
  | { type: 'PAYMENT_RESET' }
  | { type: 'OPEN_CANCEL_MODAL' }
  | { type: 'CLOSE_CANCEL_MODAL' }
  | { type: 'SET_CANCEL_REASON'; payload: { reason: string | null } }
  | { type: 'OPEN_RESUME_MODAL' }
  | { type: 'CLOSE_RESUME_MODAL' };

const initialState: SubscriptionPageState = {
  paymentFlow: 'idle',
  paymentError: null,
  cancelModalOpen: false,
  resumeModalOpen: false,
  selectedReason: null,
};

function subscriptionPageReducer(
  state: SubscriptionPageState,
  action: SubscriptionPageAction
): SubscriptionPageState {
  switch (action.type) {
    case 'PAYMENT_START':
      return {
        ...state,
        paymentFlow: 'processing',
        paymentError: null,
      };

    case 'PAYMENT_SUCCESS':
      return {
        ...state,
        paymentFlow: 'success',
        paymentError: null,
      };

    case 'PAYMENT_ERROR':
      return {
        ...state,
        paymentFlow: 'error',
        paymentError: action.payload.error,
      };

    case 'PAYMENT_RESET':
      return {
        ...state,
        paymentFlow: 'idle',
        paymentError: null,
      };

    case 'OPEN_CANCEL_MODAL':
      return {
        ...state,
        cancelModalOpen: true,
        selectedReason: null,
      };

    case 'CLOSE_CANCEL_MODAL':
      return {
        ...state,
        cancelModalOpen: false,
        selectedReason: null,
      };

    case 'SET_CANCEL_REASON':
      return {
        ...state,
        selectedReason: action.payload.reason,
      };

    case 'OPEN_RESUME_MODAL':
      return {
        ...state,
        resumeModalOpen: true,
      };

    case 'CLOSE_RESUME_MODAL':
      return {
        ...state,
        resumeModalOpen: false,
      };

    default:
      return state;
  }
}

interface SubscriptionContextValue {
  subscription: Subscription | null;
  usageInfo: UsageInfo | null;
  paymentHistories: PaymentHistory[];
  isLoadingSubscription: boolean;
  isLoadingUsage: boolean;
  isLoadingHistories: boolean;

  state: SubscriptionPageState;
  dispatch: React.Dispatch<SubscriptionPageAction>;

  subscriptionTier: 'free' | 'pro';
  isProActive: boolean;
  isCanceled: boolean;
  isExpired: boolean;
  canCancel: boolean;
  canResume: boolean;
  daysUntilExpiry: number | null;

  handleSubscribe: () => Promise<void>;
  handleCancel: () => Promise<void>;
  handleResume: () => Promise<void>;
  openCancelModal: () => void;
  closeCancelModal: () => void;
  openResumeModal: () => void;
  closeResumeModal: () => void;
  setCancelReason: (reason: string | null) => void;
}

const SubscriptionContext = createContext<SubscriptionContextValue | null>(null);

export function SubscriptionProvider({ children }: { children: React.ReactNode }) {
  const [state, dispatch] = useReducer(subscriptionPageReducer, initialState);
  const queryClient = useQueryClient();
  const { toast } = useToast();
  const { user } = useUser();
  const { getToken } = useAuth();

  const { data: subscription = null, isLoading: isLoadingSubscription } = useQuery({
    queryKey: ['subscription'],
    queryFn: async () => {
      const token = await getToken();
      const res = await apiClient.get<{ data: Subscription | null }>('/api/subscription', {
        headers: {
          Authorization: token ? `Bearer ${token}` : undefined,
        },
      });
      return res.data.data;
    },
  });

  const { data: usageInfo = null, isLoading: isLoadingUsage } = useQuery({
    queryKey: ['usage'],
    queryFn: async () => {
      const token = await getToken();
      const res = await apiClient.get<{ data: UsageInfo }>('/api/usage', {
        headers: {
          Authorization: token ? `Bearer ${token}` : undefined,
        },
      });
      return res.data.data;
    },
  });

  const { data: paymentHistories = [], isLoading: isLoadingHistories } = useQuery({
    queryKey: ['payment-histories'],
    queryFn: async () => {
      const token = await getToken();
      const res = await apiClient.get<{ data: PaymentHistory[] }>('/api/payment-histories', {
        headers: {
          Authorization: token ? `Bearer ${token}` : undefined,
        },
      });
      return res.data.data;
    },
  });

  const handleSubscribe = useCallback(async () => {
    if (!user?.id) {
      toast({
        title: '인증이 필요합니다',
        description: '로그인 후 다시 시도해주세요.',
        variant: 'destructive',
      });
      return;
    }

    dispatch({ type: 'PAYMENT_START' });

    try {
      const { loadTossPayments } = await import('@tosspayments/payment-sdk');
      const clientKey = process.env.NEXT_PUBLIC_TOSS_CLIENT_KEY;

      if (!clientKey) {
        throw new Error('토스페이먼츠 클라이언트 키가 설정되지 않았습니다.');
      }

      const tossPayments = await loadTossPayments(clientKey);
      const customerKey = user.id;
      const orderId = `ORDER_${Date.now()}_${Math.random().toString(36).substring(2, 11)}`;

      await tossPayments.requestBillingAuth('카드', {
        customerKey,
        successUrl: `${window.location.origin}/api/billing/success`,
        failUrl: `${window.location.origin}/api/billing/fail`,
      });
    } catch (error) {
      const errorMessage = extractApiErrorMessage(error, '결제 요청에 실패했습니다.');
      dispatch({ type: 'PAYMENT_ERROR', payload: { error: errorMessage } });
      toast({
        title: '결제 요청 실패',
        description: errorMessage,
        variant: 'destructive',
      });
    }
  }, [user, toast]);

  const cancelMutation = useMutation({
    mutationFn: async (reason?: string) => {
      const token = await getToken();
      return apiClient.post('/api/subscription/cancel', { reason }, {
        headers: {
          Authorization: token ? `Bearer ${token}` : undefined,
        },
      });
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['subscription'] });
      toast({ title: '구독이 취소되었습니다' });
    },
    onError: (error: unknown) => {
      toast({
        title: '구독 취소에 실패했습니다',
        description: extractApiErrorMessage(error),
        variant: 'destructive',
      });
    },
  });

  const handleCancel = useCallback(async () => {
    await cancelMutation.mutateAsync(state.selectedReason ?? undefined);
    dispatch({ type: 'CLOSE_CANCEL_MODAL' });
  }, [cancelMutation, state.selectedReason]);

  const resumeMutation = useMutation({
    mutationFn: async () => {
      const token = await getToken();
      return apiClient.post('/api/subscription/resume', {}, {
        headers: {
          Authorization: token ? `Bearer ${token}` : undefined,
        },
      });
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['subscription'] });
      toast({ title: '구독이 재개되었습니다' });
    },
    onError: (error: unknown) => {
      toast({
        title: '구독 재개에 실패했습니다',
        description: extractApiErrorMessage(error),
        variant: 'destructive',
      });
    },
  });

  const handleResume = useCallback(async () => {
    await resumeMutation.mutateAsync();
    dispatch({ type: 'CLOSE_RESUME_MODAL' });
  }, [resumeMutation]);

  const subscriptionTier = subscription?.plan ?? 'free';
  const isProActive = subscription?.plan === 'pro' && subscription?.status === 'active';
  const isCanceled = subscription?.status === 'canceled';
  const isExpired = subscription?.status === 'expired';
  const canCancel = isProActive;
  const canResume =
    isCanceled && subscription?.nextBillingDate
      ? new Date(subscription.nextBillingDate) > new Date()
      : false;
  const daysUntilExpiry = subscription?.nextBillingDate
    ? differenceInDays(new Date(subscription.nextBillingDate), new Date())
    : null;

  const value = useMemo(
    () => ({
      subscription,
      usageInfo,
      paymentHistories,
      isLoadingSubscription,
      isLoadingUsage,
      isLoadingHistories,

      state,
      dispatch,

      subscriptionTier,
      isProActive,
      isCanceled,
      isExpired,
      canCancel,
      canResume,
      daysUntilExpiry,

      handleSubscribe,
      handleCancel,
      handleResume,
      openCancelModal: () => dispatch({ type: 'OPEN_CANCEL_MODAL' }),
      closeCancelModal: () => dispatch({ type: 'CLOSE_CANCEL_MODAL' }),
      openResumeModal: () => dispatch({ type: 'OPEN_RESUME_MODAL' }),
      closeResumeModal: () => dispatch({ type: 'CLOSE_RESUME_MODAL' }),
      setCancelReason: (reason: string | null) =>
        dispatch({ type: 'SET_CANCEL_REASON', payload: { reason } }),
    }),
    [
      subscription,
      usageInfo,
      paymentHistories,
      isLoadingSubscription,
      isLoadingUsage,
      isLoadingHistories,
      state,
      subscriptionTier,
      isProActive,
      isCanceled,
      isExpired,
      canCancel,
      canResume,
      daysUntilExpiry,
      handleSubscribe,
      handleCancel,
      handleResume,
    ]
  );

  return <SubscriptionContext.Provider value={value}>{children}</SubscriptionContext.Provider>;
}

export function useSubscriptionContext() {
  const context = useContext(SubscriptionContext);
  if (!context) {
    throw new Error('useSubscriptionContext must be used within SubscriptionProvider');
  }
  return context;
}
</file>

<file path="middleware.ts">
import { clerkMiddleware, createRouteMatcher } from "@clerk/nextjs/server";
import { NextResponse } from "next/server";

const isPublicRoute = createRouteMatcher([
  "/",
  "/sign-in(.*)",
  "/sign-up(.*)",
  "/api/webhooks(.*)",
]);

export default clerkMiddleware(async (auth, request) => {
  const { userId } = await auth();
  const pathname = request.nextUrl.pathname;

  // 공개 경로는 통과
  if (isPublicRoute(request)) {
    return NextResponse.next();
  }

  // 인증되지 않은 사용자는 로그인 페이지로 리다이렉트
  if (!userId) {
    const signInUrl = new URL("/sign-in", request.url);
    signInUrl.searchParams.set("redirect_url", pathname);
    return NextResponse.redirect(signInUrl);
  }

  return NextResponse.next();
});

export const config = {
  matcher: [
    // Skip Next.js internals and all static files, unless found in search params
    "/((?!_next|[^?]*\\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)",
    // Always run for API routes
    "/(api|trpc)(.*)",
  ],
};
</file>

<file path="postcss.config.mjs">
/** @type {import('postcss-load-config').Config} */
const config = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};

export default config;
</file>

<file path="src/app/layout.tsx">
import type { Metadata } from "next";
import "./globals.css";
import Providers from "./providers";
import { ClerkProvider } from "@clerk/nextjs";

export const metadata: Metadata = {
  title: "AI 사주 분석",
  description: "AI 기반 사주 분석 구독 서비스",
};

export default async function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <ClerkProvider>
      <html lang="ko" suppressHydrationWarning>
        <body className="antialiased font-sans" suppressHydrationWarning>
          <Providers>{children}</Providers>
        </body>
      </html>
    </ClerkProvider>
  );
}
</file>

<file path="src/backend/config/index.ts">
import { z } from 'zod';
import type { AppConfig } from '@/backend/hono/context';

const envSchema = z.object({
  SUPABASE_URL: z.string().url().optional(),
  SUPABASE_SERVICE_ROLE_KEY: z.string().min(1).optional(),

  CLERK_SECRET_KEY: z.string().min(1).optional(),
  CLERK_PUBLISHABLE_KEY: z.string().min(1).optional(),
  CLERK_WEBHOOK_SIGNING_SECRET: z.string().min(1).optional(),

  GEMINI_API_KEY: z.string().min(1).optional(),

  TOSS_SECRET_KEY: z.string().min(1).optional(),
  TOSS_CLIENT_KEY: z.string().min(1).optional(),
  TOSS_WEBHOOK_SECRET: z.string().min(1).optional(),
});

let cachedConfig: AppConfig | null = null;

export const getAppConfig = (): AppConfig => {
  if (cachedConfig) {
    return cachedConfig;
  }

  // 빌드 타임에는 환경 변수 검증을 건너뜀
  const isBuildTime = process.env.NEXT_PHASE === 'phase-production-build';

  const parsed = envSchema.safeParse({
    SUPABASE_URL: process.env.SUPABASE_URL || process.env.NEXT_PUBLIC_SUPABASE_URL,
    SUPABASE_SERVICE_ROLE_KEY: process.env.SUPABASE_SERVICE_ROLE_KEY,

    CLERK_SECRET_KEY: process.env.CLERK_SECRET_KEY,
    CLERK_PUBLISHABLE_KEY: process.env.CLERK_PUBLISHABLE_KEY || process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY,
    CLERK_WEBHOOK_SIGNING_SECRET: process.env.CLERK_WEBHOOK_SIGNING_SECRET,

    GEMINI_API_KEY: process.env.GEMINI_API_KEY,

    TOSS_SECRET_KEY: process.env.TOSS_SECRET_KEY,
    TOSS_CLIENT_KEY: process.env.TOSS_CLIENT_KEY || process.env.NEXT_PUBLIC_TOSS_CLIENT_KEY,
    TOSS_WEBHOOK_SECRET: process.env.TOSS_WEBHOOK_SECRET,
  });

  if (!parsed.success && !isBuildTime) {
    const messages = parsed.error.issues
      .map((issue) => `${issue.path.join('.') || 'config'}: ${issue.message}`)
      .join('; ');
    throw new Error(`Invalid backend configuration: ${messages}`);
  }

  cachedConfig = {
    supabase: {
      url: parsed.data.SUPABASE_URL || '',
      serviceRoleKey: parsed.data.SUPABASE_SERVICE_ROLE_KEY || '',
    },
    clerk: {
      secretKey: parsed.data.CLERK_SECRET_KEY || '',
      publishableKey: parsed.data.CLERK_PUBLISHABLE_KEY || '',
      webhookSigningSecret: parsed.data.CLERK_WEBHOOK_SIGNING_SECRET || '',
    },
    gemini: {
      apiKey: parsed.data.GEMINI_API_KEY || '',
    },
    toss: {
      secretKey: parsed.data.TOSS_SECRET_KEY || '',
      clientKey: parsed.data.TOSS_CLIENT_KEY || '',
      webhookSecret: parsed.data.TOSS_WEBHOOK_SECRET || '',
    },
  } satisfies AppConfig;

  return cachedConfig;
};
</file>

<file path="src/features/analysis/context/analysis-new-context.tsx">
'use client';

import React, { createContext, useContext, useReducer } from 'react';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { useRouter } from 'next/navigation';
import { useAuth } from '@clerk/nextjs';
import { apiClient, extractApiErrorMessage } from '@/lib/remote/api-client';
import type { CreateAnalysisRequest } from '../backend/schema';
import { APP_CONFIG } from '@/constants/app';

/**
 * 사용량 정보 인터페이스
 */
export interface UsageInfo {
  subscriptionTier: 'free' | 'pro';
  used: number;
  limit: number;
  remaining: number;
  nextResetDate?: Date;
}

/**
 * 사용량 API 응답 인터페이스
 */
interface UsageResponse {
  subscriptionTier: 'free' | 'pro';
  used: number;
  limit: number;
  remaining: number;
  nextResetDate?: string;
}

/**
 * 분석 생성 API 응답 인터페이스
 */
interface AnalysisResponse {
  id: string;
  userId: string;
  birthDate: string;
  birthTime?: string;
  isLunar: boolean;
  gender: 'male' | 'female';
  result: Record<string, unknown>;
  modelUsed: string;
  createdAt: string;
}

/**
 * Context 상태 인터페이스
 */
export interface AnalysisNewState {
  usageInfo: UsageInfo | null;
  isLoadingUsage: boolean;
  usageError: Error | null;
  isSubmitting: boolean;
  submitError: string | null;
}

/**
 * Context 액션 타입
 */
export type AnalysisNewAction =
  | { type: 'FETCH_USAGE_START' }
  | { type: 'FETCH_USAGE_SUCCESS'; payload: UsageInfo }
  | { type: 'FETCH_USAGE_ERROR'; payload: Error }
  | { type: 'SUBMIT_START' }
  | { type: 'SUBMIT_SUCCESS' }
  | { type: 'SUBMIT_ERROR'; payload: string }
  | { type: 'RESET_ERROR' };

/**
 * Context value 인터페이스
 */
export interface AnalysisNewContextValue {
  state: AnalysisNewState;
  dispatch: React.Dispatch<AnalysisNewAction>;
  canSubmit: boolean;
  usageExceeded: boolean;
  isLoading: boolean;
  fetchUsage: () => Promise<void>;
  submitAnalysis: (data: CreateAnalysisRequest) => Promise<string>;
  resetError: () => void;
}

const AnalysisNewContext = createContext<AnalysisNewContextValue | null>(null);

/**
 * Reducer
 */
const initialState: AnalysisNewState = {
  usageInfo: null,
  isLoadingUsage: false,
  usageError: null,
  isSubmitting: false,
  submitError: null,
};

function analysisNewReducer(
  state: AnalysisNewState,
  action: AnalysisNewAction
): AnalysisNewState {
  switch (action.type) {
    case 'FETCH_USAGE_START':
      return { ...state, isLoadingUsage: true, usageError: null };
    case 'FETCH_USAGE_SUCCESS':
      return { ...state, isLoadingUsage: false, usageInfo: action.payload, usageError: null };
    case 'FETCH_USAGE_ERROR':
      return { ...state, isLoadingUsage: false, usageError: action.payload };
    case 'SUBMIT_START':
      return { ...state, isSubmitting: true, submitError: null };
    case 'SUBMIT_SUCCESS':
      return { ...state, isSubmitting: false, submitError: null };
    case 'SUBMIT_ERROR':
      return { ...state, isSubmitting: false, submitError: action.payload };
    case 'RESET_ERROR':
      return { ...state, submitError: null, usageError: null };
    default:
      return state;
  }
}

/**
 * Provider 컴포넌트
 */
export function AnalysisNewProvider({ children }: { children: React.ReactNode }) {
  const [state, dispatch] = useReducer(analysisNewReducer, initialState);
  const router = useRouter();
  const { getToken } = useAuth();
  const queryClient = useQueryClient();

  // React Query: 사용량 조회
  const { refetch: refetchUsage } = useQuery({
    queryKey: ['analysis', 'usage'],
    queryFn: async () => {
      const token = await getToken();
      const response = await apiClient.get<{ data: UsageResponse }>('/api/analyses/usage', {
        headers: {
          Authorization: token ? `Bearer ${token}` : undefined,
        },
      });
      return response.data.data;
    },
    enabled: false, // 수동 조회
  });

  // React Query: 분석 요청
  const analysisMutation = useMutation({
    mutationFn: async (data: CreateAnalysisRequest) => {
      const token = await getToken();
      const response = await apiClient.post<{ data: AnalysisResponse }>('/api/analyses', data, {
        headers: {
          Authorization: token ? `Bearer ${token}` : undefined,
        },
      });
      return response.data.data;
    },
    onSuccess: () => {
      // 분석 생성 후 캐시 무효화
      queryClient.invalidateQueries({ queryKey: ['analyses'] });
      queryClient.invalidateQueries({ queryKey: ['usageInfo'] });
    },
  });

  // 액션 함수: 사용량 조회
  const fetchUsage = async () => {
    dispatch({ type: 'FETCH_USAGE_START' });
    try {
      const result = await refetchUsage();
      if (result.data) {
        dispatch({
          type: 'FETCH_USAGE_SUCCESS',
          payload: {
            subscriptionTier: result.data.subscriptionTier,
            used: result.data.used,
            limit: result.data.limit,
            remaining: result.data.remaining,
            nextResetDate: result.data.nextResetDate ? new Date(result.data.nextResetDate) : undefined,
          },
        });
      } else if (result.error) {
        dispatch({ type: 'FETCH_USAGE_ERROR', payload: result.error as Error });
      }
    } catch (error) {
      dispatch({ type: 'FETCH_USAGE_ERROR', payload: error as Error });
    }
  };

  // 액션 함수: 분석 요청
  const submitAnalysis = async (data: CreateAnalysisRequest): Promise<string> => {
    dispatch({ type: 'SUBMIT_START' });
    try {
      const result = await analysisMutation.mutateAsync(data);
      dispatch({ type: 'SUBMIT_SUCCESS' });

      // 사용량 갱신
      await fetchUsage();

      return result.id;
    } catch (error) {
      const message = extractApiErrorMessage(error, '분석 요청 중 오류가 발생했습니다');
      dispatch({ type: 'SUBMIT_ERROR', payload: message });
      throw error;
    }
  };

  // 액션 함수: 에러 초기화
  const resetError = () => {
    dispatch({ type: 'RESET_ERROR' });
  };

  // 파생 데이터
  const canSubmit = Boolean(
    state.usageInfo && state.usageInfo.remaining > 0 && !state.isSubmitting
  );
  const usageExceeded = state.usageInfo?.remaining === 0;
  const isLoading = state.isLoadingUsage || state.isSubmitting;

  const value: AnalysisNewContextValue = {
    state,
    dispatch,
    canSubmit,
    usageExceeded,
    isLoading,
    fetchUsage,
    submitAnalysis,
    resetError,
  };

  return (
    <AnalysisNewContext.Provider value={value}>
      {children}
    </AnalysisNewContext.Provider>
  );
}

/**
 * Custom Hook
 */
export const useAnalysisNew = () => {
  const context = useContext(AnalysisNewContext);
  if (!context) {
    throw new Error('useAnalysisNew must be used within AnalysisNewProvider');
  }
  return context;
};
</file>

<file path="src/features/analysis/hooks/use-analysis-detail.ts">
'use client';

import { useQuery } from '@tanstack/react-query';
import { useAuth } from '@clerk/nextjs';
import { apiClient } from '@/lib/remote/api-client';
import type { AnalysisDetailResponse } from '../lib/dto';

export function useAnalysisDetail(analysisId: string) {
  const { getToken } = useAuth();

  return useQuery({
    queryKey: ['analysis', analysisId],
    queryFn: async () => {
      const token = await getToken();
      const response = await apiClient.get<{ data: AnalysisDetailResponse }>(
        `/api/analyses/${analysisId}`,
        {
          headers: {
            Authorization: token ? `Bearer ${token}` : undefined,
          },
        }
      );
      return response.data.data;
    },
    staleTime: 5 * 60 * 1000, // 5분
    gcTime: 10 * 60 * 1000, // 10분
    refetchOnWindowFocus: false,
    retry: 3,
    retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 3000),
  });
}
</file>

<file path="src/lib/remote/api-client.ts">
import axios, { isAxiosError } from "axios";

const apiClient = axios.create({
  baseURL: process.env.NEXT_PUBLIC_API_BASE_URL ?? "",
  headers: {
    "Content-Type": "application/json",
  },
});

type ErrorPayload = {
  error?: {
    message?: string;
  };
  message?: string;
};

export const extractApiErrorMessage = (
  error: unknown,
  fallbackMessage = "API request failed."
) => {
  if (isAxiosError(error)) {
    const payload = error.response?.data as ErrorPayload | undefined;

    if (typeof payload?.error?.message === "string") {
      return payload.error.message;
    }

    if (typeof payload?.message === "string") {
      return payload.message;
    }
  }

  if (error instanceof Error && error.message) {
    return error.message;
  }

  return fallbackMessage;
};

export { apiClient, isAxiosError };
</file>

<file path="package.json">
{
  "name": "template",
  "version": "0.1.0",
  "private": true,
  "engines": {
    "node": ">=20.0.0"
  },
  "scripts": {
    "dev": "next dev --turbopack",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@clerk/backend": "^2.19.0",
    "@clerk/nextjs": "^6.34.0",
    "@google/generative-ai": "^0.24.1",
    "@hono/zod-validator": "^0.7.4",
    "@hookform/resolvers": "^4",
    "@radix-ui/react-accordion": "^1.2.3",
    "@radix-ui/react-avatar": "^1.1.2",
    "@radix-ui/react-checkbox": "^1.1.1",
    "@radix-ui/react-dialog": "^1.1.15",
    "@radix-ui/react-dropdown-menu": "^2.1.1",
    "@radix-ui/react-label": "^2.1.7",
    "@radix-ui/react-progress": "^1.1.7",
    "@radix-ui/react-radio-group": "^1.3.8",
    "@radix-ui/react-select": "^2.1.4",
    "@radix-ui/react-separator": "^1.1.7",
    "@radix-ui/react-slot": "^1.1.0",
    "@radix-ui/react-toast": "^1.2.6",
    "@supabase/ssr": "^0.5.2",
    "@supabase/supabase-js": "^2.58.0",
    "@tanstack/react-query": "^5",
    "@tosspayments/payment-sdk": "^1.9.1",
    "axios": "^1.7.9",
    "class-variance-authority": "^0.7.0",
    "clsx": "^2.1.1",
    "date-fns": "^4",
    "es-toolkit": "^1",
    "framer-motion": "^11",
    "hono": "^4.9.9",
    "lucide-react": "^0.469.0",
    "next": "^15.2.3",
    "next-themes": "^0.4.3",
    "react": "^19.0.0",
    "react-dom": "^19.0.0",
    "react-hook-form": "^7",
    "react-use": "^17",
    "server-only": "0.0.1",
    "ts-pattern": "^5",
    "zod": "^3",
    "zustand": "^4"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@tailwindcss/typography": "^0.5.10",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "autoprefixer": "^10",
    "eslint": "^9",
    "eslint-config-next": "15.1.0",
    "postcss": "^8",
    "tailwind-merge": "^2.5.2",
    "tailwindcss": "^3.4.1",
    "tailwindcss-animate": "^1.0.7",
    "typescript": "^5"
  }
}
</file>

</files>
